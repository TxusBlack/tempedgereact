{"ast":null,"code":"/**\r\n * window.tracking - A modern approach for Computer Vision on the web.\r\n * @author Eduardo Lundgren <edu@rdo.io>\r\n * @version v1.1.3\r\n * @link http://window.trackingjs.com\r\n * @license BSD\r\n */\nvar faceDetect = function (window, undefined) {\n  window.tracking = window.tracking || {};\n  /**\r\n   * Inherit the prototype methods from one constructor into another.\r\n   *\r\n   * Usage:\r\n   * <pre>\r\n   * function ParentClass(a, b) { }\r\n   * ParentClass.prototype.foo = function(a) { }\r\n   *\r\n   * function ChildClass(a, b, c) {\r\n   *   window.tracking.base(this, a, b);\r\n   * }\r\n   * window.tracking.inherits(ChildClass, ParentClass);\r\n   *\r\n   * var child = new ChildClass('a', 'b', 'c');\r\n   * child.foo();\r\n   * </pre>\r\n   *\r\n   * @param {Function} childCtor Child class.\r\n   * @param {Function} parentCtor Parent class.\r\n   */\n\n  window.tracking.inherits = function (childCtor, parentCtor) {\n    function TempCtor() {}\n\n    TempCtor.prototype = parentCtor.prototype;\n    childCtor.superClass_ = parentCtor.prototype;\n    childCtor.prototype = new TempCtor();\n    childCtor.prototype.constructor = childCtor;\n    /**\r\n     * Calls superclass constructor/method.\r\n     *\r\n     * This function is only available if you use window.tracking.inherits to express\r\n     * inheritance relationships between classes.\r\n     *\r\n     * @param {!object} me Should always be \"this\".\r\n     * @param {string} methodName The method name to call. Calling superclass\r\n     *     constructor can be done with the special string 'constructor'.\r\n     * @param {...*} var_args The arguments to pass to superclass\r\n     *     method/constructor.\r\n     * @return {*} The return value of the superclass method/constructor.\r\n     */\n\n    childCtor.base = function (me, methodName) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      return parentCtor.prototype[methodName].apply(me, args);\n    };\n  };\n  /**\r\n   * Captures the user camera when window.tracking a video element and set its source\r\n   * to the camera stream.\r\n   * @param {HTMLVideoElement} element Canvas element to track.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   */\n\n\n  window.tracking.initUserMedia_ = function (element, opt_options) {\n    window.navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: opt_options && opt_options.audio ? true : false\n    }).then(function (stream) {\n      element.srcObject = stream;\n    }).catch(function (err) {\n      throw Error('Cannot capture user camera.');\n    });\n  };\n  /**\r\n   * Tests whether the object is a dom node.\r\n   * @param {object} o Object to be tested.\r\n   * @return {boolean} True if the object is a dom node.\r\n   */\n\n\n  window.tracking.isNode = function (o) {\n    return o.nodeType || this.isWindow(o);\n  };\n  /**\r\n   * Tests whether the object is the `window` object.\r\n   * @param {object} o Object to be tested.\r\n   * @return {boolean} True if the object is the `window` object.\r\n   */\n\n\n  window.tracking.isWindow = function (o) {\n    return !!(o && o.alert && o.document);\n  };\n  /**\r\n   * Selects a dom node from a CSS3 selector using `document.querySelector`.\r\n   * @param {string} selector\r\n   * @param {object} opt_element The root element for the query. When not\r\n   *     specified `document` is used as root element.\r\n   * @return {HTMLElement} The first dom element that matches to the selector.\r\n   *     If not found, returns `null`.\r\n   */\n\n\n  window.tracking.one = function (selector, opt_element) {\n    if (this.isNode(selector)) {\n      return selector;\n    }\n\n    return (opt_element || document).querySelector(selector);\n  };\n  /**\r\n   * Tracks a canvas, image or video element based on the specified `tracker`\r\n   * instance. This method extract the pixel information of the input element\r\n   * to pass to the `tracker` instance. When window.tracking a video, the\r\n   * `tracker.track(pixels, width, height)` will be in a\r\n   * `requestAnimationFrame` loop in order to track all video frames.\r\n   *\r\n   * Example:\r\n   * var tracker = new window.tracking.ColorTracker();\r\n   *\r\n   * window.tracking.track('#video', tracker);\r\n   * or\r\n   * window.tracking.track('#video', tracker, { camera: true });\r\n   *\r\n   * tracker.on('track', function(event) {\r\n   *   // console.log(event.data[0].x, event.data[0].y)\r\n   * });\r\n   *\r\n   * @param {HTMLElement} element The element to track, canvas, image or\r\n   *     video.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   */\n\n\n  window.tracking.track = function (element, tracker, opt_options) {\n    element = window.tracking.one(element);\n\n    if (!element) {\n      throw new Error('Element not found, try a different element or selector.');\n    }\n\n    if (!tracker) {\n      throw new Error('Tracker not specified, try `window.tracking.track(element, new window.tracking.FaceTracker())`.');\n    }\n\n    switch (element.nodeName.toLowerCase()) {\n      case 'canvas':\n        return this.trackCanvas_(element, tracker, opt_options);\n\n      case 'img':\n        return this.trackImg_(element, tracker, opt_options);\n\n      case 'video':\n        if (opt_options) {\n          if (opt_options.camera) {\n            this.initUserMedia_(element, opt_options);\n          }\n        }\n\n        return this.trackVideo_(element, tracker, opt_options);\n\n      default:\n        throw new Error('Element not supported, try in a canvas, img, or video.');\n    }\n  };\n  /**\r\n   * Tracks a canvas element based on the specified `tracker` instance and\r\n   * returns a `TrackerTask` for this track.\r\n   * @param {HTMLCanvasElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @return {window.tracking.TrackerTask}\r\n   * @private\r\n   */\n\n\n  window.tracking.trackCanvas_ = function (element, tracker) {\n    var self = this;\n    var task = new window.tracking.TrackerTask(tracker);\n    task.on('run', function () {\n      self.trackCanvasInternal_(element, tracker);\n    });\n    return task.run();\n  };\n  /**\r\n   * Tracks a canvas element based on the specified `tracker` instance. This\r\n   * method extract the pixel information of the input element to pass to the\r\n   * `tracker` instance.\r\n   * @param {HTMLCanvasElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @private\r\n   */\n\n\n  window.tracking.trackCanvasInternal_ = function (element, tracker) {\n    var width = element.width;\n    var height = element.height;\n    var context = element.getContext('2d');\n    var imageData = context.getImageData(0, 0, width, height);\n    tracker.track(imageData.data, width, height);\n  };\n  /**\r\n   * Tracks a image element based on the specified `tracker` instance. This\r\n   * method extract the pixel information of the input element to pass to the\r\n   * `tracker` instance.\r\n   * @param {HTMLImageElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @private\r\n   */\n\n\n  window.tracking.trackImg_ = function (element, tracker) {\n    var width = element.width;\n    var height = element.height;\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var task = new window.tracking.TrackerTask(tracker);\n    task.on('run', function () {\n      window.tracking.Canvas.loadImage(canvas, element.src, 0, 0, width, height, function () {\n        window.tracking.trackCanvasInternal_(canvas, tracker);\n      });\n    });\n    return task.run();\n  };\n  /**\r\n   * Tracks a video element based on the specified `tracker` instance. This\r\n   * method extract the pixel information of the input element to pass to the\r\n   * `tracker` instance. The `tracker.track(pixels, width, height)` will be in\r\n   * a `requestAnimationFrame` loop in order to track all video frames.\r\n   * @param {HTMLVideoElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @private\r\n   */\n\n\n  window.tracking.trackVideo_ = function (element, tracker) {\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var width;\n    var height;\n\n    var resizeCanvas_ = function resizeCanvas_() {\n      width = element.offsetWidth;\n      height = element.offsetHeight;\n      canvas.width = width;\n      canvas.height = height;\n    };\n\n    resizeCanvas_();\n    element.addEventListener('resize', resizeCanvas_);\n    var requestId;\n    var stopRequestAnimationFrame = false;\n\n    var requestAnimationFrame_ = function requestAnimationFrame_() {\n      if (stopRequestAnimationFrame) {\n        return;\n      }\n\n      requestId = window.requestAnimationFrame(function () {\n        if (element.readyState === element.HAVE_ENOUGH_DATA) {\n          try {\n            // Firefox v~30.0 gets confused with the video readyState firing an\n            // erroneous HAVE_ENOUGH_DATA just before HAVE_CURRENT_DATA state,\n            // hence keep trying to read it until resolved.\n            context.drawImage(element, 0, 0, width, height);\n          } catch (err) {}\n\n          window.tracking.trackCanvasInternal_(canvas, tracker);\n        }\n\n        requestAnimationFrame_();\n      });\n    };\n\n    var task = new window.tracking.TrackerTask(tracker);\n    task.on('stop', function () {\n      stopRequestAnimationFrame = true;\n      window.cancelAnimationFrame(requestId);\n    });\n    task.on('run', function () {\n      // setTimeout(() => {\n      stopRequestAnimationFrame = false;\n      requestAnimationFrame_(); // }, 3000);\n    });\n    task.on('stopVideoFeed', function () {\n      element.srcObject.getVideoTracks()[0].stop();\n    });\n    return task.run();\n  }; // Browser polyfills\n  //===================\n\n\n  if (!window.URL) {\n    window.URL = window.URL || window.webkitURL || window.msURL || window.oURL;\n  }\n\n  if (!navigator.getUserMedia) {\n    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n  }\n}(window);\n\n(function () {\n  /**\r\n   * EventEmitter utility.\r\n   * @constructor\r\n   */\n  window.tracking.EventEmitter = function () {};\n  /**\r\n   * Holds event listeners scoped by event type.\r\n   * @type {object}\r\n   * @private\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.events_ = null;\n  /**\r\n   * Adds a listener to the end of the listeners array for the specified event.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\n\n  window.tracking.EventEmitter.prototype.addListener = function (event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('Listener must be a function');\n    }\n\n    if (!this.events_) {\n      this.events_ = {};\n    }\n\n    this.emit('newListener', event, listener);\n\n    if (!this.events_[event]) {\n      this.events_[event] = [];\n    }\n\n    this.events_[event].push(listener);\n    return this;\n  };\n  /**\r\n   * Returns an array of listeners for the specified event.\r\n   * @param {string} event\r\n   * @return {array} Array of listeners.\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.listeners = function (event) {\n    return this.events_ && this.events_[event];\n  };\n  /**\r\n   * Execute each of the listeners in order with the supplied arguments.\r\n   * @param {string} event\r\n   * @param {*} opt_args [arg1], [arg2], [...]\r\n   * @return {boolean} Returns true if event had listeners, false otherwise.\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.emit = function (event) {\n    var listeners = this.listeners(event);\n\n    if (listeners) {\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[i].apply(this, args);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Adds a listener to the end of the listeners array for the specified event.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.on = window.tracking.EventEmitter.prototype.addListener;\n  /**\r\n   * Adds a one time listener for the event. This listener is invoked only the\r\n   * next time the event is fired, after which it is removed.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\n\n  window.tracking.EventEmitter.prototype.once = function (event, listener) {\n    var self = this;\n    self.on(event, function handlerInternal() {\n      self.removeListener(event, handlerInternal);\n      listener.apply(this, arguments);\n    });\n  };\n  /**\r\n   * Removes all listeners, or those of the specified event. It's not a good\r\n   * idea to remove listeners that were added elsewhere in the code,\r\n   * especially when it's on an emitter that you didn't create.\r\n   * @param {string} event\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.removeAllListeners = function (opt_event) {\n    if (!this.events_) {\n      return this;\n    }\n\n    if (opt_event) {\n      delete this.events_[opt_event];\n    } else {\n      delete this.events_;\n    }\n\n    return this;\n  };\n  /**\r\n   * Remove a listener from the listener array for the specified event.\r\n   * Caution: changes array indices in the listener array behind the listener.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.removeListener = function (event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('Listener must be a function');\n    }\n\n    if (!this.events_) {\n      return this;\n    }\n\n    var listeners = this.listeners(event);\n\n    if (Array.isArray(listeners)) {\n      var i = listeners.indexOf(listener);\n\n      if (i < 0) {\n        return this;\n      }\n\n      listeners.splice(i, 1);\n    }\n\n    return this;\n  };\n  /**\r\n   * By default EventEmitters will print a warning if more than 10 listeners\r\n   * are added for a particular event. This is a useful default which helps\r\n   * finding memory leaks. Obviously not all Emitters should be limited to 10.\r\n   * This function allows that to be increased. Set to zero for unlimited.\r\n   * @param {number} n The maximum number of listeners.\r\n   */\n\n\n  window.tracking.EventEmitter.prototype.setMaxListeners = function () {\n    throw new Error('Not implemented');\n  };\n})();\n\n(function () {\n  /**\r\n   * Canvas utility.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.Canvas = {};\n  /**\r\n   * Loads an image source into the canvas.\r\n   * @param {HTMLCanvasElement} canvas The canvas dom element.\r\n   * @param {string} src The image source.\r\n   * @param {number} x The canvas horizontal coordinate to load the image.\r\n   * @param {number} y The canvas vertical coordinate to load the image.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {function} opt_callback Callback that fires when the image is loaded\r\n   *     into the canvas.\r\n   * @static\r\n   */\n\n  window.tracking.Canvas.loadImage = function (canvas, src, x, y, width, height, opt_callback) {\n    var instance = this;\n    var img = new window.Image();\n    img.crossOrigin = '*';\n\n    img.onload = function () {\n      var context = canvas.getContext('2d');\n      canvas.width = width;\n      canvas.height = height;\n      context.drawImage(img, x, y, width, height);\n\n      if (opt_callback) {\n        opt_callback.call(instance);\n      }\n\n      img = null;\n    };\n\n    img.src = src;\n  };\n})();\n\n(function () {\n  /**\r\n   * DisjointSet utility with path compression. Some applications involve\r\n   * grouping n distinct objects into a collection of disjoint sets. Two\r\n   * important operations are then finding which set a given object belongs to\r\n   * and uniting the two sets. A disjoint set data structure maintains a\r\n   * collection S={ S1 , S2 ,..., Sk } of disjoint dynamic sets. Each set is\r\n   * identified by a representative, which usually is a member in the set.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.DisjointSet = function (length) {\n    if (length === undefined) {\n      throw new Error('DisjointSet length not specified.');\n    }\n\n    this.length = length;\n    this.parent = new Uint32Array(length);\n\n    for (var i = 0; i < length; i++) {\n      this.parent[i] = i;\n    }\n  };\n  /**\r\n   * Holds the length of the internal set.\r\n   * @type {number}\r\n   */\n\n\n  window.tracking.DisjointSet.prototype.length = null;\n  /**\r\n   * Holds the set containing the representative values.\r\n   * @type {Array.<number>}\r\n   */\n\n  window.tracking.DisjointSet.prototype.parent = null;\n  /**\r\n   * Finds a pointer to the representative of the set containing i.\r\n   * @param {number} i\r\n   * @return {number} The representative set of i.\r\n   */\n\n  window.tracking.DisjointSet.prototype.find = function (i) {\n    if (this.parent[i] === i) {\n      return i;\n    } else {\n      return this.parent[i] = this.find(this.parent[i]);\n    }\n  };\n  /**\r\n   * Unites two dynamic sets containing objects i and j, say Si and Sj, into\r\n   * a new set that Si ∪ Sj, assuming that Si ∩ Sj = ∅;\r\n   * @param {number} i\r\n   * @param {number} j\r\n   */\n\n\n  window.tracking.DisjointSet.prototype.union = function (i, j) {\n    var iRepresentative = this.find(i);\n    var jRepresentative = this.find(j);\n    this.parent[iRepresentative] = jRepresentative;\n  };\n})();\n\n(function () {\n  /**\r\n   * Image utility.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.Image = {};\n  /**\r\n   * Computes gaussian blur. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} diameter Gaussian blur diameter, must be greater than 1.\r\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\r\n   */\n\n  window.tracking.Image.blur = function (pixels, width, height, diameter) {\n    diameter = Math.abs(diameter);\n\n    if (diameter <= 1) {\n      throw new Error('Diameter should be greater than 1.');\n    }\n\n    var radius = diameter / 2;\n    var len = Math.ceil(diameter) + (1 - Math.ceil(diameter) % 2);\n    var weights = new Float32Array(len);\n    var rho = (radius + 0.5) / 3;\n    var rhoSq = rho * rho;\n    var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\n    var rhoFactor = -1 / (2 * rho * rho);\n    var wsum = 0;\n    var middle = Math.floor(len / 2);\n\n    for (var i = 0; i < len; i++) {\n      var x = i - middle;\n      var gx = gaussianFactor * Math.exp(x * x * rhoFactor);\n      weights[i] = gx;\n      wsum += gx;\n    }\n\n    for (var j = 0; j < weights.length; j++) {\n      weights[j] /= wsum;\n    }\n\n    return this.separableConvolve(pixels, width, height, weights, weights, false);\n  };\n  /**\r\n   * Computes the integral image for summed, squared, rotated and sobel pixels.\r\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\r\n   *     through.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} opt_integralImage Empty array of size `width * height` to\r\n   *     be filled with the integral image values. If not specified compute sum\r\n   *     values will be skipped.\r\n   * @param {array} opt_integralImageSquare Empty array of size `width *\r\n   *     height` to be filled with the integral image squared values. If not\r\n   *     specified compute squared values will be skipped.\r\n   * @param {array} opt_tiltedIntegralImage Empty array of size `width *\r\n   *     height` to be filled with the rotated integral image values. If not\r\n   *     specified compute sum values will be skipped.\r\n   * @param {array} opt_integralImageSobel Empty array of size `width *\r\n   *     height` to be filled with the integral image of sobel values. If not\r\n   *     specified compute sobel filtering will be skipped.\r\n   * @static\r\n   */\n\n\n  window.tracking.Image.computeIntegralImage = function (pixels, width, height, opt_integralImage, opt_integralImageSquare, opt_tiltedIntegralImage, opt_integralImageSobel) {\n    if (arguments.length < 4) {\n      throw new Error('You should specify at least one output array in the order: sum, square, tilted, sobel.');\n    }\n\n    var pixelsSobel;\n\n    if (opt_integralImageSobel) {\n      pixelsSobel = window.tracking.Image.sobel(pixels, width, height);\n    }\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var w = i * width * 4 + j * 4;\n        var pixel = ~~(pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114);\n\n        if (opt_integralImage) {\n          this.computePixelValueSAT_(opt_integralImage, width, i, j, pixel);\n        }\n\n        if (opt_integralImageSquare) {\n          this.computePixelValueSAT_(opt_integralImageSquare, width, i, j, pixel * pixel);\n        }\n\n        if (opt_tiltedIntegralImage) {\n          var w1 = w - width * 4;\n          var pixelAbove = ~~(pixels[w1] * 0.299 + pixels[w1 + 1] * 0.587 + pixels[w1 + 2] * 0.114);\n          this.computePixelValueRSAT_(opt_tiltedIntegralImage, width, i, j, pixel, pixelAbove || 0);\n        }\n\n        if (opt_integralImageSobel) {\n          this.computePixelValueSAT_(opt_integralImageSobel, width, i, j, pixelsSobel[w]);\n        }\n      }\n    }\n  };\n  /**\r\n   * Helper method to compute the rotated summed area table (RSAT) by the\r\n   * formula:\r\n   *\r\n   * RSAT(x, y) = RSAT(x-1, y-1) + RSAT(x+1, y-1) - RSAT(x, y-2) + I(x, y) + I(x, y-1)\r\n   *\r\n   * @param {number} width The image width.\r\n   * @param {array} RSAT Empty array of size `width * height` to be filled with\r\n   *     the integral image values. If not specified compute sum values will be\r\n   *     skipped.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} pixel Pixel value to be added to the integral image.\r\n   * @static\r\n   * @private\r\n   */\n\n\n  window.tracking.Image.computePixelValueRSAT_ = function (RSAT, width, i, j, pixel, pixelAbove) {\n    var w = i * width + j;\n    RSAT[w] = (RSAT[w - width - 1] || 0) + (RSAT[w - width + 1] || 0) - (RSAT[w - width - width] || 0) + pixel + pixelAbove;\n  };\n  /**\r\n   * Helper method to compute the summed area table (SAT) by the formula:\r\n   *\r\n   * SAT(x, y) = SAT(x, y-1) + SAT(x-1, y) + I(x, y) - SAT(x-1, y-1)\r\n   *\r\n   * @param {number} width The image width.\r\n   * @param {array} SAT Empty array of size `width * height` to be filled with\r\n   *     the integral image values. If not specified compute sum values will be\r\n   *     skipped.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} pixel Pixel value to be added to the integral image.\r\n   * @static\r\n   * @private\r\n   */\n\n\n  window.tracking.Image.computePixelValueSAT_ = function (SAT, width, i, j, pixel) {\n    var w = i * width + j;\n    SAT[w] = (SAT[w - width] || 0) + (SAT[w - 1] || 0) + pixel - (SAT[w - width - 1] || 0);\n  };\n  /**\r\n   * Converts a color from a colorspace based on an RGB color model to a\r\n   * grayscale representation of its luminance. The coefficients represent the\r\n   * measured intensity perception of typical trichromat humans, in\r\n   * particular, human vision is most sensitive to green and least sensitive\r\n   * to blue.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {boolean} fillRGBA If the result should fill all RGBA values with the gray scale\r\n   *  values, instead of returning a single value per pixel.\r\n   * @param {Uint8ClampedArray} The grayscale pixels in a linear array ([p,p,p,a,...] if fillRGBA\r\n   *  is true and [p1, p2, p3, ...] if fillRGBA is false).\r\n   * @static\r\n   */\n\n\n  window.tracking.Image.grayscale = function (pixels, width, height, fillRGBA) {\n    var gray = new Uint8ClampedArray(fillRGBA ? pixels.length : pixels.length >> 2);\n    var p = 0;\n    var w = 0;\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var value = pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114;\n        gray[p++] = value;\n\n        if (fillRGBA) {\n          gray[p++] = value;\n          gray[p++] = value;\n          gray[p++] = pixels[w + 3];\n        }\n\n        w += 4;\n      }\n    }\n\n    return gray;\n  };\n  /**\r\n   * Fast horizontal separable convolution. A point spread function (PSF) is\r\n   * said to be separable if it can be broken into two one-dimensional\r\n   * signals: a vertical and a horizontal projection. The convolution is\r\n   * performed by sliding the kernel over the image, generally starting at the\r\n   * top left corner, so as to move the kernel through all the positions where\r\n   * the kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\n\n\n  window.tracking.Image.horizontalConvolve = function (pixels, width, height, weightsVector, opaque) {\n    var side = weightsVector.length;\n    var halfSide = Math.floor(side / 2);\n    var output = new Float32Array(width * height * 4);\n    var alphaFac = opaque ? 1 : 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var sy = y;\n        var sx = x;\n        var offset = (y * width + x) * 4;\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        var a = 0;\n\n        for (var cx = 0; cx < side; cx++) {\n          var scy = sy;\n          var scx = Math.min(width - 1, Math.max(0, sx + cx - halfSide));\n          var poffset = (scy * width + scx) * 4;\n          var wt = weightsVector[cx];\n          r += pixels[poffset] * wt;\n          g += pixels[poffset + 1] * wt;\n          b += pixels[poffset + 2] * wt;\n          a += pixels[poffset + 3] * wt;\n        }\n\n        output[offset] = r;\n        output[offset + 1] = g;\n        output[offset + 2] = b;\n        output[offset + 3] = a + alphaFac * (255 - a);\n      }\n    }\n\n    return output;\n  };\n  /**\r\n   * Fast vertical separable convolution. A point spread function (PSF) is\r\n   * said to be separable if it can be broken into two one-dimensional\r\n   * signals: a vertical and a horizontal projection. The convolution is\r\n   * performed by sliding the kernel over the image, generally starting at the\r\n   * top left corner, so as to move the kernel through all the positions where\r\n   * the kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\n\n\n  window.tracking.Image.verticalConvolve = function (pixels, width, height, weightsVector, opaque) {\n    var side = weightsVector.length;\n    var halfSide = Math.floor(side / 2);\n    var output = new Float32Array(width * height * 4);\n    var alphaFac = opaque ? 1 : 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var sy = y;\n        var sx = x;\n        var offset = (y * width + x) * 4;\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        var a = 0;\n\n        for (var cy = 0; cy < side; cy++) {\n          var scy = Math.min(height - 1, Math.max(0, sy + cy - halfSide));\n          var scx = sx;\n          var poffset = (scy * width + scx) * 4;\n          var wt = weightsVector[cy];\n          r += pixels[poffset] * wt;\n          g += pixels[poffset + 1] * wt;\n          b += pixels[poffset + 2] * wt;\n          a += pixels[poffset + 3] * wt;\n        }\n\n        output[offset] = r;\n        output[offset + 1] = g;\n        output[offset + 2] = b;\n        output[offset + 3] = a + alphaFac * (255 - a);\n      }\n    }\n\n    return output;\n  };\n  /**\r\n   * Fast separable convolution. A point spread function (PSF) is said to be\r\n   * separable if it can be broken into two one-dimensional signals: a\r\n   * vertical and a horizontal projection. The convolution is performed by\r\n   * sliding the kernel over the image, generally starting at the top left\r\n   * corner, so as to move the kernel through all the positions where the\r\n   * kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} horizWeights The horizontal weighting vector, e.g [-1,0,1].\r\n   * @param {array} vertWeights The vertical vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\n\n\n  window.tracking.Image.separableConvolve = function (pixels, width, height, horizWeights, vertWeights, opaque) {\n    var vertical = this.verticalConvolve(pixels, width, height, vertWeights, opaque);\n    return this.horizontalConvolve(vertical, width, height, horizWeights, opaque);\n  };\n  /**\r\n   * Compute image edges using Sobel operator. Computes the vertical and\r\n   * horizontal gradients of the image and combines the computed images to\r\n   * find edges in the image. The way we implement the Sobel filter here is by\r\n   * first grayscaling the image, then taking the horizontal and vertical\r\n   * gradients and finally combining the gradient images to make up the final\r\n   * image. Adapted from https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\r\n   */\n\n\n  window.tracking.Image.sobel = function (pixels, width, height) {\n    pixels = this.grayscale(pixels, width, height, true);\n    var output = new Float32Array(width * height * 4);\n    var sobelSignVector = new Float32Array([-1, 0, 1]);\n    var sobelScaleVector = new Float32Array([1, 2, 1]);\n    var vertical = this.separableConvolve(pixels, width, height, sobelSignVector, sobelScaleVector);\n    var horizontal = this.separableConvolve(pixels, width, height, sobelScaleVector, sobelSignVector);\n\n    for (var i = 0; i < output.length; i += 4) {\n      var v = vertical[i];\n      var h = horizontal[i];\n      var p = Math.sqrt(h * h + v * v);\n      output[i] = p;\n      output[i + 1] = p;\n      output[i + 2] = p;\n      output[i + 3] = 255;\n    }\n\n    return output;\n  };\n  /**\r\n   * Equalizes the histogram of a grayscale image, normalizing the\r\n   * brightness and increasing the contrast of the image.\r\n   * @param {pixels} pixels The grayscale pixels in a linear array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @return {array} The equalized grayscale pixels in a linear array.\r\n   */\n\n\n  window.tracking.Image.equalizeHist = function (pixels, width, height) {\n    var equalized = new Uint8ClampedArray(pixels.length);\n    var histogram = new Array(256);\n\n    for (var i = 0; i < 256; i++) {\n      histogram[i] = 0;\n    }\n\n    for (var i = 0; i < pixels.length; i++) {\n      equalized[i] = pixels[i];\n      histogram[pixels[i]]++;\n    }\n\n    var prev = histogram[0];\n\n    for (var i = 0; i < 256; i++) {\n      histogram[i] += prev;\n      prev = histogram[i];\n    }\n\n    var norm = 255 / pixels.length;\n\n    for (var i = 0; i < pixels.length; i++) {\n      equalized[i] = histogram[pixels[i]] * norm + 0.5 | 0;\n    }\n\n    return equalized;\n  };\n})();\n\n(function () {\n  /**\r\n   * ViolaJones utility.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.ViolaJones = {};\n  /**\r\n   * Holds the minimum area of intersection that defines when a rectangle is\r\n   * from the same group. Often when a face is matched multiple rectangles are\r\n   * classified as possible rectangles to represent the face, when they\r\n   * intersects they are grouped as one face.\r\n   * @type {number}\r\n   * @default 0.5\r\n   * @static\r\n   */\n\n  window.tracking.ViolaJones.REGIONS_OVERLAP = 0.5;\n  /**\r\n   * Holds the HAAR cascade classifiers converted from OpenCV training.\r\n   * @type {array}\r\n   * @static\r\n   */\n\n  window.tracking.ViolaJones.classifiers = {};\n  /**\r\n   * Detects through the HAAR cascade data rectangles matches.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} initialScale The initial scale to start the block\r\n   *     scaling.\r\n   * @param {number} scaleFactor The scale factor to scale the feature block.\r\n   * @param {number} stepSize The block step size.\r\n   * @param {number} edgesDensity Percentage density edges inside the\r\n   *     classifier block. Value from [0.0, 1.0], defaults to 0.2. If specified\r\n   *     edge detection will be applied to the image to prune dead areas of the\r\n   *     image, this can improve significantly performance.\r\n   * @param {number} data The HAAR cascade data.\r\n   * @return {array} Found rectangles.\r\n   * @static\r\n   */\n\n  window.tracking.ViolaJones.detect = function (pixels, width, height, initialScale, scaleFactor, stepSize, edgesDensity, data) {\n    var total = 0;\n    var rects = [];\n    var integralImage = new Int32Array(width * height);\n    var integralImageSquare = new Int32Array(width * height);\n    var tiltedIntegralImage = new Int32Array(width * height);\n    var integralImageSobel;\n\n    if (edgesDensity > 0) {\n      integralImageSobel = new Int32Array(width * height);\n    }\n\n    window.tracking.Image.computeIntegralImage(pixels, width, height, integralImage, integralImageSquare, tiltedIntegralImage, integralImageSobel);\n    var minWidth = data[0];\n    var minHeight = data[1];\n    var scale = initialScale * scaleFactor;\n    var blockWidth = scale * minWidth | 0;\n    var blockHeight = scale * minHeight | 0;\n\n    while (blockWidth < width && blockHeight < height) {\n      var step = scale * stepSize + 0.5 | 0;\n\n      for (var i = 0; i < height - blockHeight; i += step) {\n        for (var j = 0; j < width - blockWidth; j += step) {\n          if (edgesDensity > 0) {\n            if (this.isTriviallyExcluded(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight)) {\n              continue;\n            }\n          }\n\n          if (this.evalStages_(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale)) {\n            rects[total++] = {\n              width: blockWidth,\n              height: blockHeight,\n              x: j,\n              y: i\n            };\n          }\n        }\n      }\n\n      scale *= scaleFactor;\n      blockWidth = scale * minWidth | 0;\n      blockHeight = scale * minHeight | 0;\n    }\n\n    return this.mergeRectangles_(rects);\n  };\n  /**\r\n   * Fast check to test whether the edges density inside the block is greater\r\n   * than a threshold, if true it tests the stages. This can improve\r\n   * significantly performance.\r\n   * @param {number} edgesDensity Percentage density edges inside the\r\n   *     classifier block.\r\n   * @param {array} integralImageSobel The integral image of a sobel image.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} width The image width.\r\n   * @return {boolean} True whether the block at position i,j can be skipped,\r\n   *     false otherwise.\r\n   * @static\r\n   * @protected\r\n   */\n\n\n  window.tracking.ViolaJones.isTriviallyExcluded = function (edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight) {\n    var wbA = i * width + j;\n    var wbB = wbA + blockWidth;\n    var wbD = wbA + blockHeight * width;\n    var wbC = wbD + blockWidth;\n    var blockEdgesDensity = (integralImageSobel[wbA] - integralImageSobel[wbB] - integralImageSobel[wbD] + integralImageSobel[wbC]) / (blockWidth * blockHeight * 255);\n\n    if (blockEdgesDensity < edgesDensity) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Evaluates if the block size on i,j position is a valid HAAR cascade\r\n   * stage.\r\n   * @param {number} data The HAAR cascade data.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} width The image width.\r\n   * @param {number} blockSize The block size.\r\n   * @param {number} scale The scale factor of the block size and its original\r\n   *     size.\r\n   * @param {number} inverseArea The inverse area of the block size.\r\n   * @return {boolean} Whether the region passes all the stage tests.\r\n   * @private\r\n   * @static\r\n   */\n\n\n  window.tracking.ViolaJones.evalStages_ = function (data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale) {\n    var inverseArea = 1.0 / (blockWidth * blockHeight);\n    var wbA = i * width + j;\n    var wbB = wbA + blockWidth;\n    var wbD = wbA + blockHeight * width;\n    var wbC = wbD + blockWidth;\n    var mean = (integralImage[wbA] - integralImage[wbB] - integralImage[wbD] + integralImage[wbC]) * inverseArea;\n    var variance = (integralImageSquare[wbA] - integralImageSquare[wbB] - integralImageSquare[wbD] + integralImageSquare[wbC]) * inverseArea - mean * mean;\n    var standardDeviation = 1;\n\n    if (variance > 0) {\n      standardDeviation = Math.sqrt(variance);\n    }\n\n    var length = data.length;\n\n    for (var w = 2; w < length;) {\n      var stageSum = 0;\n      var stageThreshold = data[w++];\n      var nodeLength = data[w++];\n\n      while (nodeLength--) {\n        var rectsSum = 0;\n        var tilted = data[w++];\n        var rectsLength = data[w++];\n\n        for (var r = 0; r < rectsLength; r++) {\n          var rectLeft = j + data[w++] * scale + 0.5 | 0;\n          var rectTop = i + data[w++] * scale + 0.5 | 0;\n          var rectWidth = data[w++] * scale + 0.5 | 0;\n          var rectHeight = data[w++] * scale + 0.5 | 0;\n          var rectWeight = data[w++];\n          var w1;\n          var w2;\n          var w3;\n          var w4;\n\n          if (tilted) {\n            // RectSum(r) = RSAT(x-h+w, y+w+h-1) + RSAT(x, y-1) - RSAT(x-h, y+h-1) - RSAT(x+w, y+w-1)\n            w1 = rectLeft - rectHeight + rectWidth + (rectTop + rectWidth + rectHeight - 1) * width;\n            w2 = rectLeft + (rectTop - 1) * width;\n            w3 = rectLeft - rectHeight + (rectTop + rectHeight - 1) * width;\n            w4 = rectLeft + rectWidth + (rectTop + rectWidth - 1) * width;\n            rectsSum += (tiltedIntegralImage[w1] + tiltedIntegralImage[w2] - tiltedIntegralImage[w3] - tiltedIntegralImage[w4]) * rectWeight;\n          } else {\n            // RectSum(r) = SAT(x-1, y-1) + SAT(x+w-1, y+h-1) - SAT(x-1, y+h-1) - SAT(x+w-1, y-1)\n            w1 = rectTop * width + rectLeft;\n            w2 = w1 + rectWidth;\n            w3 = w1 + rectHeight * width;\n            w4 = w3 + rectWidth;\n            rectsSum += (integralImage[w1] - integralImage[w2] - integralImage[w3] + integralImage[w4]) * rectWeight; // TODO: Review the code below to analyze performance when using it instead.\n            // w1 = (rectLeft - 1) + (rectTop - 1) * width;\n            // w2 = (rectLeft + rectWidth - 1) + (rectTop + rectHeight - 1) * width;\n            // w3 = (rectLeft - 1) + (rectTop + rectHeight - 1) * width;\n            // w4 = (rectLeft + rectWidth - 1) + (rectTop - 1) * width;\n            // rectsSum += (integralImage[w1] + integralImage[w2] - integralImage[w3] - integralImage[w4]) * rectWeight;\n          }\n        }\n\n        var nodeThreshold = data[w++];\n        var nodeLeft = data[w++];\n        var nodeRight = data[w++];\n\n        if (rectsSum * inverseArea < nodeThreshold * standardDeviation) {\n          stageSum += nodeLeft;\n        } else {\n          stageSum += nodeRight;\n        }\n      }\n\n      if (stageSum < stageThreshold) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Postprocess the detected sub-windows in order to combine overlapping\r\n   * detections into a single detection.\r\n   * @param {array} rects\r\n   * @return {array}\r\n   * @private\r\n   * @static\r\n   */\n\n\n  window.tracking.ViolaJones.mergeRectangles_ = function (rects) {\n    var disjointSet = new window.tracking.DisjointSet(rects.length);\n\n    for (var i = 0; i < rects.length; i++) {\n      var r1 = rects[i];\n\n      for (var j = 0; j < rects.length; j++) {\n        var r2 = rects[j];\n\n        if (window.tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\n          var x1 = Math.max(r1.x, r2.x);\n          var y1 = Math.max(r1.y, r2.y);\n          var x2 = Math.min(r1.x + r1.width, r2.x + r2.width);\n          var y2 = Math.min(r1.y + r1.height, r2.y + r2.height);\n          var overlap = (x1 - x2) * (y1 - y2);\n          var area1 = r1.width * r1.height;\n          var area2 = r2.width * r2.height;\n\n          if (overlap / (area1 * (area1 / area2)) >= this.REGIONS_OVERLAP && overlap / (area2 * (area1 / area2)) >= this.REGIONS_OVERLAP) {\n            disjointSet.union(i, j);\n          }\n        }\n      }\n    }\n\n    var map = {};\n\n    for (var k = 0; k < disjointSet.length; k++) {\n      var rep = disjointSet.find(k);\n\n      if (!map[rep]) {\n        map[rep] = {\n          total: 1,\n          width: rects[k].width,\n          height: rects[k].height,\n          x: rects[k].x,\n          y: rects[k].y\n        };\n        continue;\n      }\n\n      map[rep].total++;\n      map[rep].width += rects[k].width;\n      map[rep].height += rects[k].height;\n      map[rep].x += rects[k].x;\n      map[rep].y += rects[k].y;\n    }\n\n    var result = [];\n    Object.keys(map).forEach(function (key) {\n      var rect = map[key];\n      result.push({\n        total: rect.total,\n        width: rect.width / rect.total + 0.5 | 0,\n        height: rect.height / rect.total + 0.5 | 0,\n        x: rect.x / rect.total + 0.5 | 0,\n        y: rect.y / rect.total + 0.5 | 0\n      });\n    });\n    return result;\n  };\n})();\n\n(function () {\n  /**\r\n   * Brief intends for \"Binary Robust Independent Elementary Features\".This\r\n   * method generates a binary string for each keypoint found by an extractor\r\n   * method.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.Brief = {};\n  /**\r\n   * The set of binary tests is defined by the nd (x,y)-location pairs\r\n   * uniquely chosen during the initialization. Values could vary between N =\r\n   * 128,256,512. N=128 yield good compromises between speed, storage\r\n   * efficiency, and recognition rate.\r\n   * @type {number}\r\n   */\n\n  window.tracking.Brief.N = 512;\n  /**\r\n   * Caches coordinates values of (x,y)-location pairs uniquely chosen during\r\n   * the initialization.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\n\n  window.tracking.Brief.randomImageOffsets_ = {};\n  /**\r\n   * Caches delta values of (x,y)-location pairs uniquely chosen during\r\n   * the initialization.\r\n   * @type {Int32Array}\r\n   * @private\r\n   * @static\r\n   */\n\n  window.tracking.Brief.randomWindowOffsets_ = null;\n  /**\r\n   * Generates a binary string for each found keypoints extracted using an\r\n   * extractor method.\r\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {array} keypoints\r\n   * @return {Int32Array} Returns an array where for each four sequence int\r\n   *     values represent the descriptor binary string (128 bits) necessary\r\n   *     to describe the corner, e.g. [0,0,0,0, 0,0,0,0, ...].\r\n   * @static\r\n   */\n\n  window.tracking.Brief.getDescriptors = function (pixels, width, keypoints) {\n    // Optimizing divide by 32 operation using binary shift\n    // (this.N >> 5) === this.N/32.\n    var descriptors = new Int32Array((keypoints.length >> 1) * (this.N >> 5));\n    var descriptorWord = 0;\n    var offsets = this.getRandomOffsets_(width);\n    var position = 0;\n\n    for (var i = 0; i < keypoints.length; i += 2) {\n      var w = width * keypoints[i + 1] + keypoints[i];\n      var offsetsPosition = 0;\n\n      for (var j = 0, n = this.N; j < n; j++) {\n        if (pixels[offsets[offsetsPosition++] + w] < pixels[offsets[offsetsPosition++] + w]) {\n          // The bit in the position `j % 32` of descriptorWord should be set to 1. We do\n          // this by making an OR operation with a binary number that only has the bit\n          // in that position set to 1. That binary number is obtained by shifting 1 left by\n          // `j % 32` (which is the same as `j & 31` left) positions.\n          descriptorWord |= 1 << (j & 31);\n        } // If the next j is a multiple of 32, we will need to use a new descriptor word to hold\n        // the next results.\n\n\n        if (!(j + 1 & 31)) {\n          descriptors[position++] = descriptorWord;\n          descriptorWord = 0;\n        }\n      }\n    }\n\n    return descriptors;\n  };\n  /**\r\n   * Matches sets of features {mi} and {m′j} extracted from two images taken\r\n   * from similar, and often successive, viewpoints. A classical procedure\r\n   * runs as follows. For each point {mi} in the first image, search in a\r\n   * region of the second image around location {mi} for point {m′j}. The\r\n   * search is based on the similarity of the local image windows, also known\r\n   * as kernel windows, centered on the points, which strongly characterizes\r\n   * the points when the images are sufficiently close. Once each keypoint is\r\n   * described with its binary string, they need to be compared with the\r\n   * closest matching point. Distance metric is critical to the performance of\r\n   * in- trusion detection systems. Thus using binary strings reduces the size\r\n   * of the descriptor and provides an interesting data structure that is fast\r\n   * to operate whose similarity can be measured by the Hamming distance.\r\n   * @param {array} keypoints1\r\n   * @param {array} descriptors1\r\n   * @param {array} keypoints2\r\n   * @param {array} descriptors2\r\n   * @return {Int32Array} Returns an array where the index is the corner1\r\n   *     index coordinate, and the value is the corresponding match index of\r\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\r\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\r\n   *     the return array would be [3,0].\r\n   * @static\r\n   */\n\n\n  window.tracking.Brief.match = function (keypoints1, descriptors1, keypoints2, descriptors2) {\n    var len1 = keypoints1.length >> 1;\n    var len2 = keypoints2.length >> 1;\n    var matches = new Array(len1);\n\n    for (var i = 0; i < len1; i++) {\n      var min = Infinity;\n      var minj = 0;\n\n      for (var j = 0; j < len2; j++) {\n        var dist = 0; // Optimizing divide by 32 operation using binary shift\n        // (this.N >> 5) === this.N/32.\n\n        for (var k = 0, n = this.N >> 5; k < n; k++) {\n          dist += window.tracking.Math.hammingWeight(descriptors1[i * n + k] ^ descriptors2[j * n + k]);\n        }\n\n        if (dist < min) {\n          min = dist;\n          minj = j;\n        }\n      }\n\n      matches[i] = {\n        index1: i,\n        index2: minj,\n        keypoint1: [keypoints1[2 * i], keypoints1[2 * i + 1]],\n        keypoint2: [keypoints2[2 * minj], keypoints2[2 * minj + 1]],\n        confidence: 1 - min / this.N\n      };\n    }\n\n    return matches;\n  };\n  /**\r\n   * Removes matches outliers by testing matches on both directions.\r\n   * @param {array} keypoints1\r\n   * @param {array} descriptors1\r\n   * @param {array} keypoints2\r\n   * @param {array} descriptors2\r\n   * @return {Int32Array} Returns an array where the index is the corner1\r\n   *     index coordinate, and the value is the corresponding match index of\r\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\r\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\r\n   *     the return array would be [3,0].\r\n   * @static\r\n   */\n\n\n  window.tracking.Brief.reciprocalMatch = function (keypoints1, descriptors1, keypoints2, descriptors2) {\n    var matches = [];\n\n    if (keypoints1.length === 0 || keypoints2.length === 0) {\n      return matches;\n    }\n\n    var matches1 = window.tracking.Brief.match(keypoints1, descriptors1, keypoints2, descriptors2);\n    var matches2 = window.tracking.Brief.match(keypoints2, descriptors2, keypoints1, descriptors1);\n\n    for (var i = 0; i < matches1.length; i++) {\n      if (matches2[matches1[i].index2].index2 === i) {\n        matches.push(matches1[i]);\n      }\n    }\n\n    return matches;\n  };\n  /**\r\n   * Gets the coordinates values of (x,y)-location pairs uniquely chosen\r\n   * during the initialization.\r\n   * @return {array} Array with the random offset values.\r\n   * @private\r\n   */\n\n\n  window.tracking.Brief.getRandomOffsets_ = function (width) {\n    if (!this.randomWindowOffsets_) {\n      var windowPosition = 0;\n      var windowOffsets = new Int32Array(4 * this.N);\n\n      for (var i = 0; i < this.N; i++) {\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\n      }\n\n      this.randomWindowOffsets_ = windowOffsets;\n    }\n\n    if (!this.randomImageOffsets_[width]) {\n      var imagePosition = 0;\n      var imageOffsets = new Int32Array(2 * this.N);\n\n      for (var j = 0; j < this.N; j++) {\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j] * width + this.randomWindowOffsets_[4 * j + 1];\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j + 2] * width + this.randomWindowOffsets_[4 * j + 3];\n      }\n\n      this.randomImageOffsets_[width] = imageOffsets;\n    }\n\n    return this.randomImageOffsets_[width];\n  };\n})();\n\n(function () {\n  /**\r\n   * FAST intends for \"Features from Accelerated Segment Test\". This method\r\n   * performs a point segment test corner detection. The segment test\r\n   * criterion operates by considering a circle of sixteen pixels around the\r\n   * corner candidate p. The detector classifies p as a corner if there exists\r\n   * a set of n contiguous pixelsin the circle which are all brighter than the\r\n   * intensity of the candidate pixel Ip plus a threshold t, or all darker\r\n   * than Ip − t.\r\n   *\r\n   *       15 00 01\r\n   *    14          02\r\n   * 13                03\r\n   * 12       []       04\r\n   * 11                05\r\n   *    10          06\r\n   *       09 08 07\r\n   *\r\n   * For more reference:\r\n   * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.3991&rep=rep1&type=pdf\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.Fast = {};\n  /**\r\n   * Holds the threshold to determine whether the tested pixel is brighter or\r\n   * darker than the corner candidate p.\r\n   * @type {number}\r\n   * @default 40\r\n   * @static\r\n   */\n\n  window.tracking.Fast.THRESHOLD = 40;\n  /**\r\n   * Caches coordinates values of the circle surrounding the pixel candidate p.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\n\n  window.tracking.Fast.circles_ = {};\n  /**\r\n   * Finds corners coordinates on the graysacaled image.\r\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} threshold to determine whether the tested pixel is brighter or\r\n   *     darker than the corner candidate p. Default value is 40.\r\n   * @return {array} Array containing the coordinates of all found corners,\r\n   *     e.g. [x0,y0,x1,y1,...], where P(x0,y0) represents a corner coordinate.\r\n   * @static\r\n   */\n\n  window.tracking.Fast.findCorners = function (pixels, width, height, opt_threshold) {\n    var circleOffsets = this.getCircleOffsets_(width);\n    var circlePixels = new Int32Array(16);\n    var corners = [];\n\n    if (opt_threshold === undefined) {\n      opt_threshold = this.THRESHOLD;\n    } // When looping through the image pixels, skips the first three lines from\n    // the image boundaries to constrain the surrounding circle inside the image\n    // area.\n\n\n    for (var i = 3; i < height - 3; i++) {\n      for (var j = 3; j < width - 3; j++) {\n        var w = i * width + j;\n        var p = pixels[w]; // Loops the circle offsets to read the pixel value for the sixteen\n        // surrounding pixels.\n\n        for (var k = 0; k < 16; k++) {\n          circlePixels[k] = pixels[w + circleOffsets[k]];\n        }\n\n        if (this.isCorner(p, circlePixels, opt_threshold)) {\n          // The pixel p is classified as a corner, as optimization increment j\n          // by the circle radius 3 to skip the neighbor pixels inside the\n          // surrounding circle. This can be removed without compromising the\n          // result.\n          corners.push(j, i);\n          j += 3;\n        }\n      }\n    }\n\n    return corners;\n  };\n  /**\r\n   * Checks if the circle pixel is brighter than the candidate pixel p by\r\n   * a threshold.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\n\n\n  window.tracking.Fast.isBrighter = function (circlePixel, p, threshold) {\n    return circlePixel - p > threshold;\n  };\n  /**\r\n   * Checks if the circle pixel is within the corner of the candidate pixel p\r\n   * by a threshold.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\n\n\n  window.tracking.Fast.isCorner = function (p, circlePixels, threshold) {\n    if (this.isTriviallyExcluded(circlePixels, p, threshold)) {\n      return false;\n    }\n\n    for (var x = 0; x < 16; x++) {\n      var darker = true;\n      var brighter = true;\n\n      for (var y = 0; y < 9; y++) {\n        var circlePixel = circlePixels[x + y & 15];\n\n        if (!this.isBrighter(p, circlePixel, threshold)) {\n          brighter = false;\n\n          if (darker === false) {\n            break;\n          }\n        }\n\n        if (!this.isDarker(p, circlePixel, threshold)) {\n          darker = false;\n\n          if (brighter === false) {\n            break;\n          }\n        }\n      }\n\n      if (brighter || darker) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Checks if the circle pixel is darker than the candidate pixel p by\r\n   * a threshold.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\n\n\n  window.tracking.Fast.isDarker = function (circlePixel, p, threshold) {\n    return p - circlePixel > threshold;\n  };\n  /**\r\n   * Fast check to test if the candidate pixel is a trivially excluded value.\r\n   * In order to be a corner, the candidate pixel value should be darker or\r\n   * brighter than 9-12 surrounding pixels, when at least three of the top,\r\n   * bottom, left and right pixels are brighter or darker it can be\r\n   * automatically excluded improving the performance.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   * @protected\r\n   */\n\n\n  window.tracking.Fast.isTriviallyExcluded = function (circlePixels, p, threshold) {\n    var count = 0;\n    var circleBottom = circlePixels[8];\n    var circleLeft = circlePixels[12];\n    var circleRight = circlePixels[4];\n    var circleTop = circlePixels[0];\n\n    if (this.isBrighter(circleTop, p, threshold)) {\n      count++;\n    }\n\n    if (this.isBrighter(circleRight, p, threshold)) {\n      count++;\n    }\n\n    if (this.isBrighter(circleBottom, p, threshold)) {\n      count++;\n    }\n\n    if (this.isBrighter(circleLeft, p, threshold)) {\n      count++;\n    }\n\n    if (count < 3) {\n      count = 0;\n\n      if (this.isDarker(circleTop, p, threshold)) {\n        count++;\n      }\n\n      if (this.isDarker(circleRight, p, threshold)) {\n        count++;\n      }\n\n      if (this.isDarker(circleBottom, p, threshold)) {\n        count++;\n      }\n\n      if (this.isDarker(circleLeft, p, threshold)) {\n        count++;\n      }\n\n      if (count < 3) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Gets the sixteen offset values of the circle surrounding pixel.\r\n   * @param {number} width The image width.\r\n   * @return {array} Array with the sixteen offset values of the circle\r\n   *     surrounding pixel.\r\n   * @private\r\n   */\n\n\n  window.tracking.Fast.getCircleOffsets_ = function (width) {\n    if (this.circles_[width]) {\n      return this.circles_[width];\n    }\n\n    var circle = new Int32Array(16);\n    circle[0] = -width - width - width;\n    circle[1] = circle[0] + 1;\n    circle[2] = circle[1] + width + 1;\n    circle[3] = circle[2] + width + 1;\n    circle[4] = circle[3] + width;\n    circle[5] = circle[4] + width;\n    circle[6] = circle[5] + width - 1;\n    circle[7] = circle[6] + width - 1;\n    circle[8] = circle[7] - 1;\n    circle[9] = circle[8] - 1;\n    circle[10] = circle[9] - width - 1;\n    circle[11] = circle[10] - width - 1;\n    circle[12] = circle[11] - width;\n    circle[13] = circle[12] - width;\n    circle[14] = circle[13] - width + 1;\n    circle[15] = circle[14] - width + 1;\n    this.circles_[width] = circle;\n    return circle;\n  };\n})();\n\n(function () {\n  /**\r\n   * Math utility.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.Math = {};\n  /**\r\n   * Euclidean distance between two points P(x0, y0) and P(x1, y1).\r\n   * @param {number} x0 Horizontal coordinate of P0.\r\n   * @param {number} y0 Vertical coordinate of P0.\r\n   * @param {number} x1 Horizontal coordinate of P1.\r\n   * @param {number} y1 Vertical coordinate of P1.\r\n   * @return {number} The euclidean distance.\r\n   */\n\n  window.tracking.Math.distance = function (x0, y0, x1, y1) {\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n  /**\r\n   * Calculates the Hamming weight of a string, which is the number of symbols that are\r\n   * different from the zero-symbol of the alphabet used. It is thus\r\n   * equivalent to the Hamming distance from the all-zero string of the same\r\n   * length. For the most typical case, a string of bits, this is the number\r\n   * of 1's in the string.\r\n   *\r\n   * Example:\r\n   *\r\n   * <pre>\r\n   *  Binary string     Hamming weight\r\n   *   11101                 4\r\n   *   11101010              5\r\n   * </pre>\r\n   *\r\n   * @param {number} i Number that holds the binary string to extract the hamming weight.\r\n   * @return {number} The hamming weight.\r\n   */\n\n\n  window.tracking.Math.hammingWeight = function (i) {\n    i = i - (i >> 1 & 0x55555555);\n    i = (i & 0x33333333) + (i >> 2 & 0x33333333);\n    return (i + (i >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n  };\n  /**\r\n   * Generates a random number between [a, b] interval.\r\n   * @param {number} a\r\n   * @param {number} b\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.Math.uniformRandom = function (a, b) {\n    return a + Math.random() * (b - a);\n  };\n  /**\r\n   * Tests if a rectangle intersects with another.\r\n   *\r\n   *  <pre>\r\n   *  x0y0 --------       x2y2 --------\r\n   *      |       |           |       |\r\n   *      -------- x1y1       -------- x3y3\r\n   * </pre>\r\n   *\r\n   * @param {number} x0 Horizontal coordinate of P0.\r\n   * @param {number} y0 Vertical coordinate of P0.\r\n   * @param {number} x1 Horizontal coordinate of P1.\r\n   * @param {number} y1 Vertical coordinate of P1.\r\n   * @param {number} x2 Horizontal coordinate of P2.\r\n   * @param {number} y2 Vertical coordinate of P2.\r\n   * @param {number} x3 Horizontal coordinate of P3.\r\n   * @param {number} y3 Vertical coordinate of P3.\r\n   * @return {boolean}\r\n   */\n\n\n  window.tracking.Math.intersectRect = function (x0, y0, x1, y1, x2, y2, x3, y3) {\n    return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);\n  };\n})();\n\n(function () {\n  /**\r\n   * Matrix utility.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.Matrix = {};\n  /**\r\n   * Loops the array organized as major-row order and executes `fn` callback\r\n   * for each iteration. The `fn` callback receives the following parameters:\r\n   * `(r,g,b,a,index,i,j)`, where `r,g,b,a` represents the pixel color with\r\n   * alpha channel, `index` represents the position in the major-row order\r\n   * array and `i,j` the respective indexes positions in two dimensions.\r\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\r\n   *     through.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {function} fn The callback function for each pixel.\r\n   * @param {number} opt_jump Optional jump for the iteration, by default it\r\n   *     is 1, hence loops all the pixels of the array.\r\n   * @static\r\n   */\n\n  window.tracking.Matrix.forEach = function (pixels, width, height, fn, opt_jump) {\n    opt_jump = opt_jump || 1;\n\n    for (var i = 0; i < height; i += opt_jump) {\n      for (var j = 0; j < width; j += opt_jump) {\n        var w = i * width * 4 + j * 4;\n        fn.call(this, pixels[w], pixels[w + 1], pixels[w + 2], pixels[w + 3], w, i, j);\n      }\n    }\n  };\n  /**\r\n   * Calculates the per-element subtraction of two NxM matrices and returns a\r\n   * new NxM matrix as the result.\r\n   * @param {matrix} a The first matrix.\r\n   * @param {matrix} a The second matrix.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.sub = function (a, b) {\n    var res = window.tracking.Matrix.clone(a);\n\n    for (var i = 0; i < res.length; i++) {\n      for (var j = 0; j < res[i].length; j++) {\n        res[i][j] -= b[i][j];\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Calculates the per-element sum of two NxM matrices and returns a new NxM\r\n   * NxM matrix as the result.\r\n   * @param {matrix} a The first matrix.\r\n   * @param {matrix} a The second matrix.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.add = function (a, b) {\n    var res = window.tracking.Matrix.clone(a);\n\n    for (var i = 0; i < res.length; i++) {\n      for (var j = 0; j < res[i].length; j++) {\n        res[i][j] += b[i][j];\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Clones a matrix (or part of it) and returns a new matrix as the result.\r\n   * @param {matrix} src The matrix to be cloned.\r\n   * @param {number} width The second matrix.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.clone = function (src, width, height) {\n    width = width || src[0].length;\n    height = height || src.length;\n    var temp = new Array(height);\n    var i = height;\n\n    while (i--) {\n      temp[i] = new Array(width);\n      var j = width;\n\n      while (j--) {\n        temp[i][j] = src[i][j];\n      }\n    }\n\n    return temp;\n  };\n  /**\r\n   * Multiply a matrix by a scalar and returns a new matrix as the result.\r\n   * @param {number} scalar The scalar to multiply the matrix by.\r\n   * @param {matrix} src The matrix to be multiplied.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.mulScalar = function (scalar, src) {\n    var res = window.tracking.Matrix.clone(src);\n\n    for (var i = 0; i < src.length; i++) {\n      for (var j = 0; j < src[i].length; j++) {\n        res[i][j] *= scalar;\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Transpose a matrix and returns a new matrix as the result.\r\n   * @param {matrix} src The matrix to be transposed.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.transpose = function (src) {\n    var transpose = new Array(src[0].length);\n\n    for (var i = 0; i < src[0].length; i++) {\n      transpose[i] = new Array(src.length);\n\n      for (var j = 0; j < src.length; j++) {\n        transpose[i][j] = src[j][i];\n      }\n    }\n\n    return transpose;\n  };\n  /**\r\n   * Multiply an MxN matrix with an NxP matrix and returns a new MxP matrix\r\n   * as the result.\r\n   * @param {matrix} a The first matrix.\r\n   * @param {matrix} b The second matrix.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.mul = function (a, b) {\n    var res = new Array(a.length);\n\n    for (var i = 0; i < a.length; i++) {\n      res[i] = new Array(b[0].length);\n\n      for (var j = 0; j < b[0].length; j++) {\n        res[i][j] = 0;\n\n        for (var k = 0; k < a[0].length; k++) {\n          res[i][j] += a[i][k] * b[k][j];\n        }\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Calculates the absolute norm of a matrix.\r\n   * @param {matrix} src The matrix which norm will be calculated.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.norm = function (src) {\n    var res = 0;\n\n    for (var i = 0; i < src.length; i++) {\n      for (var j = 0; j < src[i].length; j++) {\n        res += src[i][j] * src[i][j];\n      }\n    }\n\n    return Math.sqrt(res);\n  };\n  /**\r\n   * Calculates and returns the covariance matrix of a set of vectors as well\r\n   * as the mean of the matrix.\r\n   * @param {matrix} src The matrix which covariance matrix will be calculated.\r\n   * @static\r\n   */\n\n\n  window.tracking.Matrix.calcCovarMatrix = function (src) {\n    var mean = new Array(src.length);\n\n    for (var i = 0; i < src.length; i++) {\n      mean[i] = [0.0];\n\n      for (var j = 0; j < src[i].length; j++) {\n        mean[i][0] += src[i][j] / src[i].length;\n      }\n    }\n\n    var deltaFull = window.tracking.Matrix.clone(mean);\n\n    for (var i = 0; i < deltaFull.length; i++) {\n      for (var j = 0; j < src[0].length - 1; j++) {\n        deltaFull[i].push(deltaFull[i][0]);\n      }\n    }\n\n    var a = window.tracking.Matrix.sub(src, deltaFull);\n    var b = window.tracking.Matrix.transpose(a);\n    var covar = window.tracking.Matrix.mul(b, a);\n    return [covar, mean];\n  };\n})();\n\n(function () {\n  /**\r\n   * EPnp utility.\r\n   * @static\r\n   * @constructor\r\n   */\n  window.tracking.EPnP = {};\n\n  window.tracking.EPnP.solve = function (objectPoints, imagePoints, cameraMatrix) {};\n})();\n\n(function () {\n  /**\r\n   * Tracker utility.\r\n   * @constructor\r\n   * @extends {window.tracking.EventEmitter}\r\n   */\n  window.tracking.Tracker = function () {\n    window.tracking.Tracker.base(this, 'constructor');\n  };\n\n  window.tracking.inherits(window.tracking.Tracker, window.tracking.EventEmitter);\n  /**\r\n   * Tracks the pixels on the array. This method is called for each video\r\n   * frame in order to emit `track` event.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   */\n\n  window.tracking.Tracker.prototype.track = function () {};\n})();\n\n(function () {\n  /**\r\n   * TrackerTask utility.\r\n   * @constructor\r\n   * @extends {window.tracking.EventEmitter}\r\n   */\n  window.tracking.TrackerTask = function (tracker) {\n    window.tracking.TrackerTask.base(this, 'constructor');\n\n    if (!tracker) {\n      throw new Error('Tracker instance not specified.');\n    }\n\n    this.setTracker(tracker);\n  };\n\n  window.tracking.inherits(window.tracking.TrackerTask, window.tracking.EventEmitter);\n  /**\r\n   * Holds the tracker instance managed by this task.\r\n   * @type {window.tracking.Tracker}\r\n   * @private\r\n   */\n\n  window.tracking.TrackerTask.prototype.tracker_ = null;\n  /**\r\n   * Holds if the tracker task is in running.\r\n   * @type {boolean}\r\n   * @private\r\n   */\n\n  window.tracking.TrackerTask.prototype.running_ = false;\n  /**\r\n   * Gets the tracker instance managed by this task.\r\n   * @return {window.tracking.Tracker}\r\n   */\n\n  window.tracking.TrackerTask.prototype.getTracker = function () {\n    return this.tracker_;\n  };\n  /**\r\n   * Returns true if the tracker task is in running, false otherwise.\r\n   * @return {boolean}\r\n   * @private\r\n   */\n\n\n  window.tracking.TrackerTask.prototype.inRunning = function () {\n    return this.running_;\n  };\n  /**\r\n   * Sets if the tracker task is in running.\r\n   * @param {boolean} running\r\n   * @private\r\n   */\n\n\n  window.tracking.TrackerTask.prototype.setRunning = function (running) {\n    this.running_ = running;\n  };\n  /**\r\n   * Sets the tracker instance managed by this task.\r\n   * @return {window.tracking.Tracker}\r\n   */\n\n\n  window.tracking.TrackerTask.prototype.setTracker = function (tracker) {\n    this.tracker_ = tracker;\n  };\n  /**\r\n   * Emits a `run` event on the tracker task for the implementers to run any\r\n   * child action, e.g. `requestAnimationFrame`.\r\n   * @return {object} Returns itself, so calls can be chained.\r\n   */\n\n\n  window.tracking.TrackerTask.prototype.run = function () {\n    var self = this;\n\n    if (this.inRunning()) {\n      return;\n    }\n\n    this.setRunning(true);\n\n    this.reemitTrackEvent_ = function (event) {\n      self.emit('track', event);\n    };\n\n    this.tracker_.on('track', this.reemitTrackEvent_);\n    this.emit('run');\n    return this;\n  };\n  /**\r\n   * Emits a `stop` event on the tracker task for the implementers to stop any\r\n   * child action being done, e.g. `requestAnimationFrame`.\r\n   * @return {object} Returns itself, so calls can be chained.\r\n   */\n\n\n  window.tracking.TrackerTask.prototype.stop = function () {\n    if (!this.inRunning()) {\n      return;\n    }\n\n    this.setRunning(false);\n    this.emit('stop');\n    this.tracker_.removeListener('track', this.reemitTrackEvent_);\n    return this;\n  };\n})();\n\n(function () {\n  /**\r\n   * ColorTracker utility to track colored blobs in a frame using color\r\n   * difference evaluation.\r\n   * @constructor\r\n   * @param {string|Array.<string>} opt_colors Optional colors to track.\r\n   * @extends {window.tracking.Tracker}\r\n   */\n  window.tracking.ColorTracker = function (opt_colors) {\n    window.tracking.ColorTracker.base(this, 'constructor');\n\n    if (typeof opt_colors === 'string') {\n      opt_colors = [opt_colors];\n    }\n\n    if (opt_colors) {\n      opt_colors.forEach(function (color) {\n        if (!window.tracking.ColorTracker.getColor(color)) {\n          throw new Error('Color not valid, try `new window.tracking.ColorTracker(\"magenta\")`.');\n        }\n      });\n      this.setColors(opt_colors);\n    }\n  };\n\n  window.tracking.inherits(window.tracking.ColorTracker, window.tracking.Tracker);\n  /**\r\n   * Holds the known colors.\r\n   * @type {Object.<string, function>}\r\n   * @private\r\n   * @static\r\n   */\n\n  window.tracking.ColorTracker.knownColors_ = {};\n  /**\r\n   * Caches coordinates values of the neighbours surrounding a pixel.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\n\n  window.tracking.ColorTracker.neighbours_ = {};\n  /**\r\n   * Registers a color as known color.\r\n   * @param {string} name The color name.\r\n   * @param {function} fn The color function to test if the passed (r,g,b) is\r\n   *     the desired color.\r\n   * @static\r\n   */\n\n  window.tracking.ColorTracker.registerColor = function (name, fn) {\n    window.tracking.ColorTracker.knownColors_[name] = fn;\n  };\n  /**\r\n   * Gets the known color function that is able to test whether an (r,g,b) is\r\n   * the desired color.\r\n   * @param {string} name The color name.\r\n   * @return {function} The known color test function.\r\n   * @static\r\n   */\n\n\n  window.tracking.ColorTracker.getColor = function (name) {\n    return window.tracking.ColorTracker.knownColors_[name];\n  };\n  /**\r\n   * Holds the colors to be tracked by the `ColorTracker` instance.\r\n   * @default ['magenta']\r\n   * @type {Array.<string>}\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.colors = ['magenta'];\n  /**\r\n   * Holds the minimum dimension to classify a rectangle.\r\n   * @default 20\r\n   * @type {number}\r\n   */\n\n  window.tracking.ColorTracker.prototype.minDimension = 20;\n  /**\r\n   * Holds the maximum dimension to classify a rectangle.\r\n   * @default Infinity\r\n   * @type {number}\r\n   */\n\n  window.tracking.ColorTracker.prototype.maxDimension = Infinity;\n  /**\r\n   * Holds the minimum group size to be classified as a rectangle.\r\n   * @default 30\r\n   * @type {number}\r\n   */\n\n  window.tracking.ColorTracker.prototype.minGroupSize = 30;\n  /**\r\n   * Calculates the central coordinate from the cloud points. The cloud points\r\n   * are all points that matches the desired color.\r\n   * @param {Array.<number>} cloud Major row order array containing all the\r\n   *     points from the desired color, e.g. [x1, y1, c2, y2, ...].\r\n   * @param {number} total Total numbers of pixels of the desired color.\r\n   * @return {object} Object containing the x, y and estimated z coordinate of\r\n   *     the blog extracted from the cloud points.\r\n   * @private\r\n   */\n\n  window.tracking.ColorTracker.prototype.calculateDimensions_ = function (cloud, total) {\n    var maxx = -1;\n    var maxy = -1;\n    var minx = Infinity;\n    var miny = Infinity;\n\n    for (var c = 0; c < total; c += 2) {\n      var x = cloud[c];\n      var y = cloud[c + 1];\n\n      if (x < minx) {\n        minx = x;\n      }\n\n      if (x > maxx) {\n        maxx = x;\n      }\n\n      if (y < miny) {\n        miny = y;\n      }\n\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n\n    return {\n      width: maxx - minx,\n      height: maxy - miny,\n      x: minx,\n      y: miny\n    };\n  };\n  /**\r\n   * Gets the colors being tracked by the `ColorTracker` instance.\r\n   * @return {Array.<string>}\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.getColors = function () {\n    return this.colors;\n  };\n  /**\r\n   * Gets the minimum dimension to classify a rectangle.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.getMinDimension = function () {\n    return this.minDimension;\n  };\n  /**\r\n   * Gets the maximum dimension to classify a rectangle.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.getMaxDimension = function () {\n    return this.maxDimension;\n  };\n  /**\r\n   * Gets the minimum group size to be classified as a rectangle.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.getMinGroupSize = function () {\n    return this.minGroupSize;\n  };\n  /**\r\n   * Gets the eight offset values of the neighbours surrounding a pixel.\r\n   * @param {number} width The image width.\r\n   * @return {array} Array with the eight offset values of the neighbours\r\n   *     surrounding a pixel.\r\n   * @private\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.getNeighboursForWidth_ = function (width) {\n    if (window.tracking.ColorTracker.neighbours_[width]) {\n      return window.tracking.ColorTracker.neighbours_[width];\n    }\n\n    var neighbours = new Int32Array(8);\n    neighbours[0] = -width * 4;\n    neighbours[1] = -width * 4 + 4;\n    neighbours[2] = 4;\n    neighbours[3] = width * 4 + 4;\n    neighbours[4] = width * 4;\n    neighbours[5] = width * 4 - 4;\n    neighbours[6] = -4;\n    neighbours[7] = -width * 4 - 4;\n    window.tracking.ColorTracker.neighbours_[width] = neighbours;\n    return neighbours;\n  };\n  /**\r\n   * Unites groups whose bounding box intersect with each other.\r\n   * @param {Array.<Object>} rects\r\n   * @private\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.mergeRectangles_ = function (rects) {\n    var intersects;\n    var results = [];\n    var minDimension = this.getMinDimension();\n    var maxDimension = this.getMaxDimension();\n\n    for (var r = 0; r < rects.length; r++) {\n      var r1 = rects[r];\n      intersects = true;\n\n      for (var s = r + 1; s < rects.length; s++) {\n        var r2 = rects[s];\n\n        if (window.tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\n          intersects = false;\n          var x1 = Math.min(r1.x, r2.x);\n          var y1 = Math.min(r1.y, r2.y);\n          var x2 = Math.max(r1.x + r1.width, r2.x + r2.width);\n          var y2 = Math.max(r1.y + r1.height, r2.y + r2.height);\n          r2.height = y2 - y1;\n          r2.width = x2 - x1;\n          r2.x = x1;\n          r2.y = y1;\n          break;\n        }\n      }\n\n      if (intersects) {\n        if (r1.width >= minDimension && r1.height >= minDimension) {\n          if (r1.width <= maxDimension && r1.height <= maxDimension) {\n            results.push(r1);\n          }\n        }\n      }\n    }\n\n    return results;\n  };\n  /**\r\n   * Sets the colors to be tracked by the `ColorTracker` instance.\r\n   * @param {Array.<string>} colors\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.setColors = function (colors) {\n    this.colors = colors;\n  };\n  /**\r\n   * Sets the minimum dimension to classify a rectangle.\r\n   * @param {number} minDimension\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.setMinDimension = function (minDimension) {\n    this.minDimension = minDimension;\n  };\n  /**\r\n   * Sets the maximum dimension to classify a rectangle.\r\n   * @param {number} maxDimension\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.setMaxDimension = function (maxDimension) {\n    this.maxDimension = maxDimension;\n  };\n  /**\r\n   * Sets the minimum group size to be classified as a rectangle.\r\n   * @param {number} minGroupSize\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.setMinGroupSize = function (minGroupSize) {\n    this.minGroupSize = minGroupSize;\n  };\n  /**\r\n   * Tracks the `Video` frames. This method is called for each video frame in\r\n   * order to emit `track` event.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.track = function (pixels, width, height) {\n    var self = this;\n    var colors = this.getColors();\n\n    if (!colors) {\n      throw new Error('Colors not specified, try `new window.tracking.ColorTracker(\"magenta\")`.');\n    }\n\n    var results = [];\n    colors.forEach(function (color) {\n      results = results.concat(self.trackColor_(pixels, width, height, color));\n    });\n    this.emit('track', {\n      data: results\n    });\n  };\n  /**\r\n   * Find the given color in the given matrix of pixels using Flood fill\r\n   * algorithm to determines the area connected to a given node in a\r\n   * multi-dimensional array.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   * @param {string} color The color to be found\r\n   * @private\r\n   */\n\n\n  window.tracking.ColorTracker.prototype.trackColor_ = function (pixels, width, height, color) {\n    var colorFn = window.tracking.ColorTracker.knownColors_[color];\n    var currGroup = new Int32Array(pixels.length >> 2);\n    var currGroupSize;\n    var currI;\n    var currJ;\n    var currW;\n    var marked = new Int8Array(pixels.length);\n    var minGroupSize = this.getMinGroupSize();\n    var neighboursW = this.getNeighboursForWidth_(width);\n    var queue = new Int32Array(pixels.length);\n    var queuePosition;\n    var results = [];\n    var w = -4;\n\n    if (!colorFn) {\n      return results;\n    }\n\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        w += 4;\n\n        if (marked[w]) {\n          continue;\n        }\n\n        currGroupSize = 0;\n        queuePosition = -1;\n        queue[++queuePosition] = w;\n        queue[++queuePosition] = i;\n        queue[++queuePosition] = j;\n        marked[w] = 1;\n\n        while (queuePosition >= 0) {\n          currJ = queue[queuePosition--];\n          currI = queue[queuePosition--];\n          currW = queue[queuePosition--];\n\n          if (colorFn(pixels[currW], pixels[currW + 1], pixels[currW + 2], pixels[currW + 3], currW, currI, currJ)) {\n            currGroup[currGroupSize++] = currJ;\n            currGroup[currGroupSize++] = currI;\n\n            for (var k = 0; k < neighboursW.length; k++) {\n              var otherW = currW + neighboursW[k];\n              var otherI = currI + neighboursI[k];\n              var otherJ = currJ + neighboursJ[k];\n\n              if (!marked[otherW] && otherI >= 0 && otherI < height && otherJ >= 0 && otherJ < width) {\n                queue[++queuePosition] = otherW;\n                queue[++queuePosition] = otherI;\n                queue[++queuePosition] = otherJ;\n                marked[otherW] = 1;\n              }\n            }\n          }\n        }\n\n        if (currGroupSize >= minGroupSize) {\n          var data = this.calculateDimensions_(currGroup, currGroupSize);\n\n          if (data) {\n            data.color = color;\n            results.push(data);\n          }\n        }\n      }\n    }\n\n    return this.mergeRectangles_(results);\n  }; // Default colors\n  //===================\n\n\n  window.tracking.ColorTracker.registerColor('cyan', function (r, g, b) {\n    var thresholdGreen = 50,\n        thresholdBlue = 70,\n        dx = r - 0,\n        dy = g - 255,\n        dz = b - 255;\n\n    if (g - r >= thresholdGreen && b - r >= thresholdBlue) {\n      return true;\n    }\n\n    return dx * dx + dy * dy + dz * dz < 6400;\n  });\n  window.tracking.ColorTracker.registerColor('magenta', function (r, g, b) {\n    var threshold = 50,\n        dx = r - 255,\n        dy = g - 0,\n        dz = b - 255;\n\n    if (r - g >= threshold && b - g >= threshold) {\n      return true;\n    }\n\n    return dx * dx + dy * dy + dz * dz < 19600;\n  });\n  window.tracking.ColorTracker.registerColor('yellow', function (r, g, b) {\n    var threshold = 50,\n        dx = r - 255,\n        dy = g - 255,\n        dz = b - 0;\n\n    if (r - b >= threshold && g - b >= threshold) {\n      return true;\n    }\n\n    return dx * dx + dy * dy + dz * dz < 10000;\n  }); // Caching neighbour i/j offset values.\n  //=====================================\n\n  var neighboursI = new Int32Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n  var neighboursJ = new Int32Array([0, 1, 1, 1, 0, -1, -1, -1]);\n})();\n\n(function () {\n  /**\r\n   * ObjectTracker utility.\r\n   * @constructor\r\n   * @param {string|Array.<string|Array.<number>>} opt_classifiers Optional\r\n   *     object classifiers to track.\r\n   * @extends {window.tracking.Tracker}\r\n   */\n  window.tracking.ObjectTracker = function (opt_classifiers) {\n    window.tracking.ObjectTracker.base(this, 'constructor');\n\n    if (opt_classifiers) {\n      if (!Array.isArray(opt_classifiers)) {\n        opt_classifiers = [opt_classifiers];\n      }\n\n      if (Array.isArray(opt_classifiers)) {\n        opt_classifiers.forEach(function (classifier, i) {\n          if (typeof classifier === 'string') {\n            opt_classifiers[i] = window.tracking.ViolaJones.classifiers[classifier];\n          }\n\n          if (!opt_classifiers[i]) {\n            throw new Error('Object classifier not valid, try `new window.tracking.ObjectTracker(\"face\")`.');\n          }\n        });\n      }\n    }\n\n    this.setClassifiers(opt_classifiers);\n  };\n\n  window.tracking.inherits(window.tracking.ObjectTracker, window.tracking.Tracker);\n  /**\r\n   * Specifies the edges density of a block in order to decide whether to skip\r\n   * it or not.\r\n   * @default 0.2\r\n   * @type {number}\r\n   */\n\n  window.tracking.ObjectTracker.prototype.edgesDensity = 0.2;\n  /**\r\n   * Specifies the initial scale to start the feature block scaling.\r\n   * @default 1.0\r\n   * @type {number}\r\n   */\n\n  window.tracking.ObjectTracker.prototype.initialScale = 1.0;\n  /**\r\n   * Specifies the scale factor to scale the feature block.\r\n   * @default 1.25\r\n   * @type {number}\r\n   */\n\n  window.tracking.ObjectTracker.prototype.scaleFactor = 1.25;\n  /**\r\n   * Specifies the block step size.\r\n   * @default 1.5\r\n   * @type {number}\r\n   */\n\n  window.tracking.ObjectTracker.prototype.stepSize = 1.5;\n  /**\r\n   * Gets the tracker HAAR classifiers.\r\n   * @return {TypedArray.<number>}\r\n   */\n\n  window.tracking.ObjectTracker.prototype.getClassifiers = function () {\n    return this.classifiers;\n  };\n  /**\r\n   * Gets the edges density value.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.getEdgesDensity = function () {\n    return this.edgesDensity;\n  };\n  /**\r\n   * Gets the initial scale to start the feature block scaling.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.getInitialScale = function () {\n    return this.initialScale;\n  };\n  /**\r\n   * Gets the scale factor to scale the feature block.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.getScaleFactor = function () {\n    return this.scaleFactor;\n  };\n  /**\r\n   * Gets the block step size.\r\n   * @return {number}\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.getStepSize = function () {\n    return this.stepSize;\n  };\n  /**\r\n   * Tracks the `Video` frames. This method is called for each video frame in\r\n   * order to emit `track` event.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.track = function (pixels, width, height) {\n    var self = this;\n    var classifiers = this.getClassifiers();\n\n    if (!classifiers) {\n      throw new Error('Object classifier not specified, try `new window.tracking.ObjectTracker(\"face\")`.');\n    }\n\n    var results = [];\n    classifiers.forEach(function (classifier) {\n      results = results.concat(window.tracking.ViolaJones.detect(pixels, width, height, self.getInitialScale(), self.getScaleFactor(), self.getStepSize(), self.getEdgesDensity(), classifier));\n    });\n    this.emit('track', {\n      data: results\n    });\n  };\n  /**\r\n   * Sets the tracker HAAR classifiers.\r\n   * @param {TypedArray.<number>} classifiers\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.setClassifiers = function (classifiers) {\n    this.classifiers = classifiers;\n  };\n  /**\r\n   * Sets the edges density.\r\n   * @param {number} edgesDensity\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.setEdgesDensity = function (edgesDensity) {\n    this.edgesDensity = edgesDensity;\n  };\n  /**\r\n   * Sets the initial scale to start the block scaling.\r\n   * @param {number} initialScale\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.setInitialScale = function (initialScale) {\n    this.initialScale = initialScale;\n  };\n  /**\r\n   * Sets the scale factor to scale the feature block.\r\n   * @param {number} scaleFactor\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.setScaleFactor = function (scaleFactor) {\n    this.scaleFactor = scaleFactor;\n  };\n  /**\r\n   * Sets the block step size.\r\n   * @param {number} stepSize\r\n   */\n\n\n  window.tracking.ObjectTracker.prototype.setStepSize = function (stepSize) {\n    this.stepSize = stepSize;\n  };\n})();\n\n(function () {\n  window.tracking.LandmarksTracker = function () {\n    window.tracking.LandmarksTracker.base(this, 'constructor');\n  };\n\n  window.tracking.inherits(window.tracking.LandmarksTracker, window.tracking.ObjectTracker);\n\n  window.tracking.LandmarksTracker.prototype.track = function (pixels, width, height) {\n    var image = {\n      'data': pixels,\n      'width': width,\n      'height': height\n    };\n    var classifier = window.tracking.ViolaJones.classifiers['face'];\n    var faces = window.tracking.ViolaJones.detect(pixels, width, height, this.getInitialScale(), this.getScaleFactor(), this.getStepSize(), this.getEdgesDensity(), classifier);\n    var landmarks = window.tracking.LBF.align(pixels, width, height, faces);\n    this.emit('track', {\n      'data': {\n        'faces': faces,\n        'landmarks': landmarks\n      }\n    });\n  };\n})();\n\n(function () {\n  window.tracking.LBF = {};\n  /**\r\n   * LBF Regressor utility.\r\n   * @constructor\r\n   */\n\n  window.tracking.LBF.Regressor = function (maxNumStages) {\n    this.maxNumStages = maxNumStages;\n    this.rfs = new Array(maxNumStages);\n    this.models = new Array(maxNumStages);\n\n    for (var i = 0; i < maxNumStages; i++) {\n      this.rfs[i] = new window.tracking.LBF.RandomForest(i);\n      this.models[i] = window.tracking.LBF.RegressorData[i].models;\n    }\n\n    this.meanShape = window.tracking.LBF.LandmarksData;\n  };\n  /**\r\n   * Predicts the position of the landmarks based on the bounding box of the face.\r\n   * @param {pixels} pixels The grayscale pixels in a linear array.\r\n   * @param {number} width Width of the image.\r\n   * @param {number} height Height of the image.\r\n   * @param {object} boudingBox Bounding box of the face to be aligned.\r\n   * @return {matrix} A matrix with each landmark position in a row [x,y].\r\n   */\n\n\n  window.tracking.LBF.Regressor.prototype.predict = function (pixels, width, height, boundingBox) {\n    var images = [];\n    var currentShapes = [];\n    var boundingBoxes = [];\n    var meanShapeClone = window.tracking.Matrix.clone(this.meanShape);\n    images.push({\n      'data': pixels,\n      'width': width,\n      'height': height\n    });\n    boundingBoxes.push(boundingBox);\n    currentShapes.push(window.tracking.LBF.projectShapeToBoundingBox_(meanShapeClone, boundingBox));\n\n    for (var stage = 0; stage < this.maxNumStages; stage++) {\n      var binaryFeatures = window.tracking.LBF.Regressor.deriveBinaryFeat(this.rfs[stage], images, currentShapes, boundingBoxes, meanShapeClone);\n      this.applyGlobalPrediction(binaryFeatures, this.models[stage], currentShapes, boundingBoxes);\n    }\n\n    return currentShapes[0];\n  };\n  /**\r\n   * Multiplies the binary features of the landmarks with the regression matrix\r\n   * to obtain the displacement for each landmark. Then applies this displacement\r\n   * into the landmarks shape.\r\n   * @param {object} binaryFeatures The binary features for the landmarks.\r\n   * @param {object} models The regressor models.\r\n   * @param {matrix} currentShapes The landmarks shapes.\r\n   * @param {array} boudingBoxes The bounding boxes of the faces.\r\n   */\n\n\n  window.tracking.LBF.Regressor.prototype.applyGlobalPrediction = function (binaryFeatures, models, currentShapes, boundingBoxes) {\n    var residual = currentShapes[0].length * 2;\n    var rotation = [];\n    var deltashape = new Array(residual / 2);\n\n    for (var i = 0; i < residual / 2; i++) {\n      deltashape[i] = [0.0, 0.0];\n    }\n\n    for (var i = 0; i < currentShapes.length; i++) {\n      for (var j = 0; j < residual; j++) {\n        var tmp = 0;\n\n        for (var lx = 0, idx = 0; (idx = binaryFeatures[i][lx].index) != -1; lx++) {\n          if (idx <= models[j].nr_feature) {\n            tmp += models[j].data[idx - 1] * binaryFeatures[i][lx].value;\n          }\n        }\n\n        if (j < residual / 2) {\n          deltashape[j][0] = tmp;\n        } else {\n          deltashape[j - residual / 2][1] = tmp;\n        }\n      }\n\n      var res = window.tracking.LBF.similarityTransform_(window.tracking.LBF.unprojectShapeToBoundingBox_(currentShapes[i], boundingBoxes[i]), this.meanShape);\n      var rotation = window.tracking.Matrix.transpose(res[0]);\n      var s = window.tracking.LBF.unprojectShapeToBoundingBox_(currentShapes[i], boundingBoxes[i]);\n      s = window.tracking.Matrix.add(s, deltashape);\n      currentShapes[i] = window.tracking.LBF.projectShapeToBoundingBox_(s, boundingBoxes[i]);\n    }\n  };\n  /**\r\n   * Derives the binary features from the image for each landmark.\r\n   * @param {object} forest The random forest to search for the best binary feature match.\r\n   * @param {array} images The images with pixels in a grayscale linear array.\r\n   * @param {array} currentShapes The current landmarks shape.\r\n   * @param {array} boudingBoxes The bounding boxes of the faces.\r\n   * @param {matrix} meanShape The mean shape of the current landmarks set.\r\n   * @return {array} The binary features extracted from the image and matched with the\r\n   *     training data.\r\n   * @static\r\n   */\n\n\n  window.tracking.LBF.Regressor.deriveBinaryFeat = function (forest, images, currentShapes, boundingBoxes, meanShape) {\n    var binaryFeatures = new Array(images.length);\n\n    for (var i = 0; i < images.length; i++) {\n      var t = forest.maxNumTrees * forest.landmarkNum + 1;\n      binaryFeatures[i] = new Array(t);\n\n      for (var j = 0; j < t; j++) {\n        binaryFeatures[i][j] = {};\n      }\n    }\n\n    var leafnodesPerTree = 1 << forest.maxDepth - 1;\n\n    for (var i = 0; i < images.length; i++) {\n      var projectedShape = window.tracking.LBF.unprojectShapeToBoundingBox_(currentShapes[i], boundingBoxes[i]);\n      var transform = window.tracking.LBF.similarityTransform_(projectedShape, meanShape);\n\n      for (var j = 0; j < forest.landmarkNum; j++) {\n        for (var k = 0; k < forest.maxNumTrees; k++) {\n          var binaryCode = window.tracking.LBF.Regressor.getCodeFromTree(forest.rfs[j][k], images[i], currentShapes[i], boundingBoxes[i], transform[0], transform[1]);\n          var index = j * forest.maxNumTrees + k;\n          binaryFeatures[i][index].index = leafnodesPerTree * index + binaryCode;\n          binaryFeatures[i][index].value = 1;\n        }\n      }\n\n      binaryFeatures[i][forest.landmarkNum * forest.maxNumTrees].index = -1;\n      binaryFeatures[i][forest.landmarkNum * forest.maxNumTrees].value = -1;\n    }\n\n    return binaryFeatures;\n  };\n  /**\r\n   * Gets the binary code for a specific tree in a random forest. For each landmark,\r\n   * the position from two pre-defined points are recovered from the training data\r\n   * and then the intensity of the pixels corresponding to these points is extracted\r\n   * from the image and used to traverse the trees in the random forest. At the end,\r\n   * the ending nodes will be represented by 1, and the remaining nodes by 0.\r\n   *\r\n   * +--------------------------- Random Forest -----------------------------+\r\n   * | Ø = Ending leaf                                                       |\r\n   * |                                                                       |\r\n   * |       O             O             O             O             O       |\r\n   * |     /   \\         /   \\         /   \\         /   \\         /   \\     |\r\n   * |    O     O       O     O       O     O       O     O       O     O    |\r\n   * |   / \\   / \\     / \\   / \\     / \\   / \\     / \\   / \\     / \\   / \\   |\r\n   * |  Ø   O O   O   O   O Ø   O   O   Ø O   O   O   O Ø   O   O   O O   Ø  |\r\n   * |  1   0 0   0   0   0 1   0   0   1 0   0   0   0 1   0   0   0 0   1  |\r\n   * +-----------------------------------------------------------------------+\r\n   * Final binary code for this landmark: 10000010010000100001\r\n   *\r\n   * @param {object} forest The tree to be analyzed.\r\n   * @param {array} image The image with pixels in a grayscale linear array.\r\n   * @param {matrix} shape The current landmarks shape.\r\n   * @param {object} boudingBoxes The bounding box of the face.\r\n   * @param {matrix} rotation The rotation matrix used to transform the projected landmarks\r\n   *     into the mean shape.\r\n   * @param {number} scale The scale factor used to transform the projected landmarks\r\n   *     into the mean shape.\r\n   * @return {number} The binary code extracted from the tree.\r\n   * @static\r\n   */\n\n\n  window.tracking.LBF.Regressor.getCodeFromTree = function (tree, image, shape, boundingBox, rotation, scale) {\n    var current = 0;\n    var bincode = 0;\n\n    while (true) {\n      var x1 = Math.cos(tree.nodes[current].feats[0]) * tree.nodes[current].feats[2] * tree.maxRadioRadius * boundingBox.width;\n      var y1 = Math.sin(tree.nodes[current].feats[0]) * tree.nodes[current].feats[2] * tree.maxRadioRadius * boundingBox.height;\n      var x2 = Math.cos(tree.nodes[current].feats[1]) * tree.nodes[current].feats[3] * tree.maxRadioRadius * boundingBox.width;\n      var y2 = Math.sin(tree.nodes[current].feats[1]) * tree.nodes[current].feats[3] * tree.maxRadioRadius * boundingBox.height;\n      var project_x1 = rotation[0][0] * x1 + rotation[0][1] * y1;\n      var project_y1 = rotation[1][0] * x1 + rotation[1][1] * y1;\n      var real_x1 = Math.floor(project_x1 + shape[tree.landmarkID][0]);\n      var real_y1 = Math.floor(project_y1 + shape[tree.landmarkID][1]);\n      real_x1 = Math.max(0.0, Math.min(real_x1, image.height - 1.0));\n      real_y1 = Math.max(0.0, Math.min(real_y1, image.width - 1.0));\n      var project_x2 = rotation[0][0] * x2 + rotation[0][1] * y2;\n      var project_y2 = rotation[1][0] * x2 + rotation[1][1] * y2;\n      var real_x2 = Math.floor(project_x2 + shape[tree.landmarkID][0]);\n      var real_y2 = Math.floor(project_y2 + shape[tree.landmarkID][1]);\n      real_x2 = Math.max(0.0, Math.min(real_x2, image.height - 1.0));\n      real_y2 = Math.max(0.0, Math.min(real_y2, image.width - 1.0));\n      var pdf = Math.floor(image.data[real_y1 * image.width + real_x1]) - Math.floor(image.data[real_y2 * image.width + real_x2]);\n\n      if (pdf < tree.nodes[current].thresh) {\n        current = tree.nodes[current].cnodes[0];\n      } else {\n        current = tree.nodes[current].cnodes[1];\n      }\n\n      if (tree.nodes[current].is_leafnode == 1) {\n        bincode = 1;\n\n        for (var i = 0; i < tree.leafnodes.length; i++) {\n          if (tree.leafnodes[i] == current) {\n            return bincode;\n          }\n\n          bincode++;\n        }\n\n        return bincode;\n      }\n    }\n\n    return bincode;\n  };\n})();\n\n(function () {\n  /**\r\n   * Face Alignment via Regressing Local Binary Features (LBF)\r\n   * This approach has two components: a set of local binary features and\r\n   * a locality principle for learning those features.\r\n   * The locality principle is used to guide the learning of a set of highly\r\n   * discriminative local binary features for each landmark independently.\r\n   * The obtained local binary features are used to learn a linear regression\r\n   * that later will be used to guide the landmarks in the alignment phase.\r\n   *\r\n   * @authors: VoxarLabs Team (http://cin.ufpe.br/~voxarlabs)\r\n   *           Lucas Figueiredo <lsf@cin.ufpe.br>, Thiago Menezes <tmc2@cin.ufpe.br>,\r\n   *           Thiago Domingues <tald@cin.ufpe.br>, Rafael Roberto <rar3@cin.ufpe.br>,\r\n   *           Thulio Araujo <tlsa@cin.ufpe.br>, Joao Victor <jvfl@cin.ufpe.br>,\r\n   *           Tomer Simis <tls@cin.ufpe.br>)\r\n   */\n\n  /**\r\n   * Holds the maximum number of stages that will be used in the alignment algorithm.\r\n   * Each stage contains a different set of random forests and retrieves the binary\r\n   * code from a more \"specialized\" (i.e. smaller) region around the landmarks.\r\n   * @type {number}\r\n   * @static\r\n   */\n  window.tracking.LBF.maxNumStages = 4;\n  /**\r\n   * Holds the regressor that will be responsible for extracting the local features from\r\n   * the image and guide the landmarks using the training data.\r\n   * @type {object}\r\n   * @protected\r\n   * @static\r\n   */\n\n  window.tracking.LBF.regressor_ = null;\n  /**\r\n   * Generates a set of landmarks for a set of faces\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} faces The list of faces detected in the image\r\n   * @return {array} The aligned landmarks, each set of landmarks corresponding\r\n   *     to a specific face.\r\n   * @static\r\n   */\n\n  window.tracking.LBF.align = function (pixels, width, height, faces) {\n    if (window.tracking.LBF.regressor_ == null) {\n      window.tracking.LBF.regressor_ = new window.tracking.LBF.Regressor(window.tracking.LBF.maxNumStages);\n    }\n\n    pixels = window.tracking.Image.grayscale(pixels, width, height, false);\n    pixels = window.tracking.Image.equalizeHist(pixels, width, height);\n    var shapes = new Array(faces.length);\n\n    for (var i in faces) {\n      faces[i].height = faces[i].width;\n      var boundingBox = {};\n      boundingBox.startX = faces[i].x;\n      boundingBox.startY = faces[i].y;\n      boundingBox.width = faces[i].width;\n      boundingBox.height = faces[i].height;\n      shapes[i] = window.tracking.LBF.regressor_.predict(pixels, width, height, boundingBox);\n    }\n\n    return shapes;\n  };\n  /**\r\n   * Unprojects the landmarks shape from the bounding box.\r\n   * @param {matrix} shape The landmarks shape.\r\n   * @param {matrix} boudingBox The bounding box.\r\n   * @return {matrix} The landmarks shape projected into the bounding box.\r\n   * @static\r\n   * @protected\r\n   */\n\n\n  window.tracking.LBF.unprojectShapeToBoundingBox_ = function (shape, boundingBox) {\n    var temp = new Array(shape.length);\n\n    for (var i = 0; i < shape.length; i++) {\n      temp[i] = [(shape[i][0] - boundingBox.startX) / boundingBox.width, (shape[i][1] - boundingBox.startY) / boundingBox.height];\n    }\n\n    return temp;\n  };\n  /**\r\n   * Projects the landmarks shape into the bounding box. The landmarks shape has\r\n   * normalized coordinates, so it is necessary to map these coordinates into\r\n   * the bounding box coordinates.\r\n   * @param {matrix} shape The landmarks shape.\r\n   * @param {matrix} boudingBox The bounding box.\r\n   * @return {matrix} The landmarks shape.\r\n   * @static\r\n   * @protected\r\n   */\n\n\n  window.tracking.LBF.projectShapeToBoundingBox_ = function (shape, boundingBox) {\n    var temp = new Array(shape.length);\n\n    for (var i = 0; i < shape.length; i++) {\n      temp[i] = [shape[i][0] * boundingBox.width + boundingBox.startX, shape[i][1] * boundingBox.height + boundingBox.startY];\n    }\n\n    return temp;\n  };\n  /**\r\n   * Calculates the rotation and scale necessary to transform shape1 into shape2.\r\n   * @param {matrix} shape1 The shape to be transformed.\r\n   * @param {matrix} shape2 The shape to be transformed in.\r\n   * @return {[matrix, scalar]} The rotation matrix and scale that applied to shape1\r\n   *     results in shape2.\r\n   * @static\r\n   * @protected\r\n   */\n\n\n  window.tracking.LBF.similarityTransform_ = function (shape1, shape2) {\n    var center1 = [0, 0];\n    var center2 = [0, 0];\n\n    for (var i = 0; i < shape1.length; i++) {\n      center1[0] += shape1[i][0];\n      center1[1] += shape1[i][1];\n      center2[0] += shape2[i][0];\n      center2[1] += shape2[i][1];\n    }\n\n    center1[0] /= shape1.length;\n    center1[1] /= shape1.length;\n    center2[0] /= shape2.length;\n    center2[1] /= shape2.length;\n    var temp1 = window.tracking.Matrix.clone(shape1);\n    var temp2 = window.tracking.Matrix.clone(shape2);\n\n    for (var i = 0; i < shape1.length; i++) {\n      temp1[i][0] -= center1[0];\n      temp1[i][1] -= center1[1];\n      temp2[i][0] -= center2[0];\n      temp2[i][1] -= center2[1];\n    }\n\n    var covariance1, covariance2;\n    var mean1, mean2;\n    var t = window.tracking.Matrix.calcCovarMatrix(temp1);\n    covariance1 = t[0];\n    mean1 = t[1];\n    t = window.tracking.Matrix.calcCovarMatrix(temp2);\n    covariance2 = t[0];\n    mean2 = t[1];\n    var s1 = Math.sqrt(window.tracking.Matrix.norm(covariance1));\n    var s2 = Math.sqrt(window.tracking.Matrix.norm(covariance2));\n    var scale = s1 / s2;\n    temp1 = window.tracking.Matrix.mulScalar(1.0 / s1, temp1);\n    temp2 = window.tracking.Matrix.mulScalar(1.0 / s2, temp2);\n    var num = 0,\n        den = 0;\n\n    for (var i = 0; i < shape1.length; i++) {\n      num = num + temp1[i][1] * temp2[i][0] - temp1[i][0] * temp2[i][1];\n      den = den + temp1[i][0] * temp2[i][0] + temp1[i][1] * temp2[i][1];\n    }\n\n    var norm = Math.sqrt(num * num + den * den);\n    var sin_theta = num / norm;\n    var cos_theta = den / norm;\n    var rotation = [[cos_theta, -sin_theta], [sin_theta, cos_theta]];\n    return [rotation, scale];\n  };\n  /**\r\n   * LBF Random Forest data structure.\r\n   * @static\r\n   * @constructor\r\n   */\n\n\n  window.tracking.LBF.RandomForest = function (forestIndex) {\n    this.maxNumTrees = window.tracking.LBF.RegressorData[forestIndex].max_numtrees;\n    this.landmarkNum = window.tracking.LBF.RegressorData[forestIndex].num_landmark;\n    this.maxDepth = window.tracking.LBF.RegressorData[forestIndex].max_depth;\n    this.stages = window.tracking.LBF.RegressorData[forestIndex].stages;\n    this.rfs = new Array(this.landmarkNum);\n\n    for (var i = 0; i < this.landmarkNum; i++) {\n      this.rfs[i] = new Array(this.maxNumTrees);\n\n      for (var j = 0; j < this.maxNumTrees; j++) {\n        this.rfs[i][j] = new window.tracking.LBF.Tree(forestIndex, i, j);\n      }\n    }\n  };\n  /**\r\n   * LBF Tree data structure.\r\n   * @static\r\n   * @constructor\r\n   */\n\n\n  window.tracking.LBF.Tree = function (forestIndex, landmarkIndex, treeIndex) {\n    var data = window.tracking.LBF.RegressorData[forestIndex].landmarks[landmarkIndex][treeIndex];\n    this.maxDepth = data.max_depth;\n    this.maxNumNodes = data.max_numnodes;\n    this.nodes = data.nodes;\n    this.landmarkID = data.landmark_id;\n    this.numLeafnodes = data.num_leafnodes;\n    this.numNodes = data.num_nodes;\n    this.maxNumFeats = data.max_numfeats;\n    this.maxRadioRadius = data.max_radio_radius;\n    this.leafnodes = data.id_leafnodes;\n  };\n})();\n\nexport default faceDetect;","map":{"version":3,"sources":["C:\\Users\\migue\\Documents\\Jose\\TempEdge\\tempedgereact\\tempedgereact\\src\\Pages\\FaceMash\\assets\\tracking.js"],"names":["faceDetect","window","undefined","tracking","inherits","childCtor","parentCtor","TempCtor","prototype","superClass_","constructor","base","me","methodName","args","Array","slice","call","arguments","apply","initUserMedia_","element","opt_options","navigator","mediaDevices","getUserMedia","video","audio","then","stream","srcObject","catch","err","Error","isNode","o","nodeType","isWindow","alert","document","one","selector","opt_element","querySelector","track","tracker","nodeName","toLowerCase","trackCanvas_","trackImg_","camera","trackVideo_","self","task","TrackerTask","on","trackCanvasInternal_","run","width","height","context","getContext","imageData","getImageData","data","canvas","createElement","Canvas","loadImage","src","resizeCanvas_","offsetWidth","offsetHeight","addEventListener","requestId","stopRequestAnimationFrame","requestAnimationFrame_","requestAnimationFrame","readyState","HAVE_ENOUGH_DATA","drawImage","cancelAnimationFrame","getVideoTracks","stop","URL","webkitURL","msURL","oURL","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","EventEmitter","events_","addListener","event","listener","TypeError","emit","push","listeners","i","length","once","handlerInternal","removeListener","removeAllListeners","opt_event","isArray","indexOf","splice","setMaxListeners","x","y","opt_callback","instance","img","Image","crossOrigin","onload","DisjointSet","parent","Uint32Array","find","union","j","iRepresentative","jRepresentative","blur","pixels","diameter","Math","abs","radius","len","ceil","weights","Float32Array","rho","rhoSq","gaussianFactor","sqrt","PI","rhoFactor","wsum","middle","floor","gx","exp","separableConvolve","computeIntegralImage","opt_integralImage","opt_integralImageSquare","opt_tiltedIntegralImage","opt_integralImageSobel","pixelsSobel","sobel","w","pixel","computePixelValueSAT_","w1","pixelAbove","computePixelValueRSAT_","RSAT","SAT","grayscale","fillRGBA","gray","Uint8ClampedArray","p","value","horizontalConvolve","weightsVector","opaque","side","halfSide","output","alphaFac","sy","sx","offset","r","g","b","a","cx","scy","scx","min","max","poffset","wt","verticalConvolve","cy","horizWeights","vertWeights","vertical","sobelSignVector","sobelScaleVector","horizontal","v","h","equalizeHist","equalized","histogram","prev","norm","ViolaJones","REGIONS_OVERLAP","classifiers","detect","initialScale","scaleFactor","stepSize","edgesDensity","total","rects","integralImage","Int32Array","integralImageSquare","tiltedIntegralImage","integralImageSobel","minWidth","minHeight","scale","blockWidth","blockHeight","step","isTriviallyExcluded","evalStages_","mergeRectangles_","wbA","wbB","wbD","wbC","blockEdgesDensity","inverseArea","mean","variance","standardDeviation","stageSum","stageThreshold","nodeLength","rectsSum","tilted","rectsLength","rectLeft","rectTop","rectWidth","rectHeight","rectWeight","w2","w3","w4","nodeThreshold","nodeLeft","nodeRight","disjointSet","r1","r2","intersectRect","x1","y1","x2","y2","overlap","area1","area2","map","k","rep","result","Object","keys","forEach","key","rect","Brief","N","randomImageOffsets_","randomWindowOffsets_","getDescriptors","keypoints","descriptors","descriptorWord","offsets","getRandomOffsets_","position","offsetsPosition","n","match","keypoints1","descriptors1","keypoints2","descriptors2","len1","len2","matches","Infinity","minj","dist","hammingWeight","index1","index2","keypoint1","keypoint2","confidence","reciprocalMatch","matches1","matches2","windowPosition","windowOffsets","round","uniformRandom","imagePosition","imageOffsets","Fast","THRESHOLD","circles_","findCorners","opt_threshold","circleOffsets","getCircleOffsets_","circlePixels","corners","isCorner","isBrighter","circlePixel","threshold","darker","brighter","isDarker","count","circleBottom","circleLeft","circleRight","circleTop","circle","distance","x0","y0","dx","dy","random","x3","y3","Matrix","fn","opt_jump","sub","res","clone","add","temp","mulScalar","scalar","transpose","mul","calcCovarMatrix","deltaFull","covar","EPnP","solve","objectPoints","imagePoints","cameraMatrix","Tracker","setTracker","tracker_","running_","getTracker","inRunning","setRunning","running","reemitTrackEvent_","ColorTracker","opt_colors","color","getColor","setColors","knownColors_","neighbours_","registerColor","name","colors","minDimension","maxDimension","minGroupSize","calculateDimensions_","cloud","maxx","maxy","minx","miny","c","getColors","getMinDimension","getMaxDimension","getMinGroupSize","getNeighboursForWidth_","neighbours","intersects","results","s","setMinDimension","setMaxDimension","setMinGroupSize","concat","trackColor_","colorFn","currGroup","currGroupSize","currI","currJ","currW","marked","Int8Array","neighboursW","queue","queuePosition","otherW","otherI","neighboursI","otherJ","neighboursJ","thresholdGreen","thresholdBlue","dz","ObjectTracker","opt_classifiers","classifier","setClassifiers","getClassifiers","getEdgesDensity","getInitialScale","getScaleFactor","getStepSize","setEdgesDensity","setInitialScale","setScaleFactor","setStepSize","LandmarksTracker","image","faces","landmarks","LBF","align","Regressor","maxNumStages","rfs","models","RandomForest","RegressorData","meanShape","LandmarksData","predict","boundingBox","images","currentShapes","boundingBoxes","meanShapeClone","projectShapeToBoundingBox_","stage","binaryFeatures","deriveBinaryFeat","applyGlobalPrediction","residual","rotation","deltashape","tmp","lx","idx","index","nr_feature","similarityTransform_","unprojectShapeToBoundingBox_","forest","t","maxNumTrees","landmarkNum","leafnodesPerTree","maxDepth","projectedShape","transform","binaryCode","getCodeFromTree","tree","shape","current","bincode","cos","nodes","feats","maxRadioRadius","sin","project_x1","project_y1","real_x1","landmarkID","real_y1","project_x2","project_y2","real_x2","real_y2","pdf","thresh","cnodes","is_leafnode","leafnodes","regressor_","shapes","startX","startY","shape1","shape2","center1","center2","temp1","temp2","covariance1","covariance2","mean1","mean2","s1","s2","num","den","sin_theta","cos_theta","forestIndex","max_numtrees","num_landmark","max_depth","stages","Tree","landmarkIndex","treeIndex","maxNumNodes","max_numnodes","landmark_id","numLeafnodes","num_leafnodes","numNodes","num_nodes","maxNumFeats","max_numfeats","max_radio_radius","id_leafnodes"],"mappings":"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","sourcesContent":["/**\r\n * window.tracking - A modern approach for Computer Vision on the web.\r\n * @author Eduardo Lundgren <edu@rdo.io>\r\n * @version v1.1.3\r\n * @link http://window.trackingjs.com\r\n * @license BSD\r\n */\r\nlet faceDetect = (function(window, undefined) {\r\n  window.tracking = window.tracking || {};\r\n\r\n  /**\r\n   * Inherit the prototype methods from one constructor into another.\r\n   *\r\n   * Usage:\r\n   * <pre>\r\n   * function ParentClass(a, b) { }\r\n   * ParentClass.prototype.foo = function(a) { }\r\n   *\r\n   * function ChildClass(a, b, c) {\r\n   *   window.tracking.base(this, a, b);\r\n   * }\r\n   * window.tracking.inherits(ChildClass, ParentClass);\r\n   *\r\n   * var child = new ChildClass('a', 'b', 'c');\r\n   * child.foo();\r\n   * </pre>\r\n   *\r\n   * @param {Function} childCtor Child class.\r\n   * @param {Function} parentCtor Parent class.\r\n   */\r\n  window.tracking.inherits = function(childCtor, parentCtor) {\r\n    function TempCtor() {\r\n    }\r\n    TempCtor.prototype = parentCtor.prototype;\r\n    childCtor.superClass_ = parentCtor.prototype;\r\n    childCtor.prototype = new TempCtor();\r\n    childCtor.prototype.constructor = childCtor;\r\n\r\n    /**\r\n     * Calls superclass constructor/method.\r\n     *\r\n     * This function is only available if you use window.tracking.inherits to express\r\n     * inheritance relationships between classes.\r\n     *\r\n     * @param {!object} me Should always be \"this\".\r\n     * @param {string} methodName The method name to call. Calling superclass\r\n     *     constructor can be done with the special string 'constructor'.\r\n     * @param {...*} var_args The arguments to pass to superclass\r\n     *     method/constructor.\r\n     * @return {*} The return value of the superclass method/constructor.\r\n     */\r\n    childCtor.base = function(me, methodName) {\r\n      var args = Array.prototype.slice.call(arguments, 2);\r\n      return parentCtor.prototype[methodName].apply(me, args);\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Captures the user camera when window.tracking a video element and set its source\r\n   * to the camera stream.\r\n   * @param {HTMLVideoElement} element Canvas element to track.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   */\r\n  window.tracking.initUserMedia_ = function(element, opt_options) {\r\n    window.navigator.mediaDevices.getUserMedia({\r\n      video: true,\r\n      audio: (opt_options && opt_options.audio) ? true : false,\r\n    }).then(function(stream) {\r\n      element.srcObject = stream;\r\n    }).catch(function(err) {\r\n      throw Error('Cannot capture user camera.');\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Tests whether the object is a dom node.\r\n   * @param {object} o Object to be tested.\r\n   * @return {boolean} True if the object is a dom node.\r\n   */\r\n  window.tracking.isNode = function(o) {\r\n    return o.nodeType || this.isWindow(o);\r\n  };\r\n\r\n  /**\r\n   * Tests whether the object is the `window` object.\r\n   * @param {object} o Object to be tested.\r\n   * @return {boolean} True if the object is the `window` object.\r\n   */\r\n  window.tracking.isWindow = function(o) {\r\n    return !!(o && o.alert && o.document);\r\n  };\r\n\r\n  /**\r\n   * Selects a dom node from a CSS3 selector using `document.querySelector`.\r\n   * @param {string} selector\r\n   * @param {object} opt_element The root element for the query. When not\r\n   *     specified `document` is used as root element.\r\n   * @return {HTMLElement} The first dom element that matches to the selector.\r\n   *     If not found, returns `null`.\r\n   */\r\n  window.tracking.one = function(selector, opt_element) {\r\n    if (this.isNode(selector)) {\r\n      return selector;\r\n    }\r\n    return (opt_element || document).querySelector(selector);\r\n  };\r\n\r\n  /**\r\n   * Tracks a canvas, image or video element based on the specified `tracker`\r\n   * instance. This method extract the pixel information of the input element\r\n   * to pass to the `tracker` instance. When window.tracking a video, the\r\n   * `tracker.track(pixels, width, height)` will be in a\r\n   * `requestAnimationFrame` loop in order to track all video frames.\r\n   *\r\n   * Example:\r\n   * var tracker = new window.tracking.ColorTracker();\r\n   *\r\n   * window.tracking.track('#video', tracker);\r\n   * or\r\n   * window.tracking.track('#video', tracker, { camera: true });\r\n   *\r\n   * tracker.on('track', function(event) {\r\n   *   // console.log(event.data[0].x, event.data[0].y)\r\n   * });\r\n   *\r\n   * @param {HTMLElement} element The element to track, canvas, image or\r\n   *     video.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   */\r\n\r\n  window.tracking.track = function(element, tracker, opt_options) {\r\n    element = window.tracking.one(element);\r\n    if (!element) {\r\n      throw new Error('Element not found, try a different element or selector.');\r\n    }\r\n    if (!tracker) {\r\n      throw new Error('Tracker not specified, try `window.tracking.track(element, new window.tracking.FaceTracker())`.');\r\n    }\r\n\r\n    switch (element.nodeName.toLowerCase()) {\r\n      case 'canvas':\r\n        return this.trackCanvas_(element, tracker, opt_options);\r\n      case 'img':\r\n        return this.trackImg_(element, tracker, opt_options);\r\n      case 'video':\r\n        if (opt_options) {\r\n          if (opt_options.camera) {\r\n            this.initUserMedia_(element, opt_options);\r\n          }\r\n        }\r\n        return this.trackVideo_(element, tracker, opt_options);\r\n      default:\r\n        throw new Error('Element not supported, try in a canvas, img, or video.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Tracks a canvas element based on the specified `tracker` instance and\r\n   * returns a `TrackerTask` for this track.\r\n   * @param {HTMLCanvasElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @return {window.tracking.TrackerTask}\r\n   * @private\r\n   */\r\n  window.tracking.trackCanvas_ = function(element, tracker) {\r\n    var self = this;\r\n    var task = new window.tracking.TrackerTask(tracker);\r\n    task.on('run', function() {\r\n      self.trackCanvasInternal_(element, tracker);\r\n    });\r\n    return task.run();\r\n  };\r\n\r\n  /**\r\n   * Tracks a canvas element based on the specified `tracker` instance. This\r\n   * method extract the pixel information of the input element to pass to the\r\n   * `tracker` instance.\r\n   * @param {HTMLCanvasElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @private\r\n   */\r\n  window.tracking.trackCanvasInternal_ = function(element, tracker) {\r\n    var width = element.width;\r\n    var height = element.height;\r\n    var context = element.getContext('2d');\r\n    var imageData = context.getImageData(0, 0, width, height);\r\n    tracker.track(imageData.data, width, height);\r\n  };\r\n\r\n  /**\r\n   * Tracks a image element based on the specified `tracker` instance. This\r\n   * method extract the pixel information of the input element to pass to the\r\n   * `tracker` instance.\r\n   * @param {HTMLImageElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @private\r\n   */\r\n  window.tracking.trackImg_ = function(element, tracker) {\r\n    var width = element.width;\r\n    var height = element.height;\r\n    var canvas = document.createElement('canvas');\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    var task = new window.tracking.TrackerTask(tracker);\r\n    task.on('run', function() {\r\n      window.tracking.Canvas.loadImage(canvas, element.src, 0, 0, width, height, function() {\r\n        window.tracking.trackCanvasInternal_(canvas, tracker);\r\n      });\r\n    });\r\n    return task.run();\r\n  };\r\n\r\n  /**\r\n   * Tracks a video element based on the specified `tracker` instance. This\r\n   * method extract the pixel information of the input element to pass to the\r\n   * `tracker` instance. The `tracker.track(pixels, width, height)` will be in\r\n   * a `requestAnimationFrame` loop in order to track all video frames.\r\n   * @param {HTMLVideoElement} element Canvas element to track.\r\n   * @param {window.tracking.Tracker} tracker The tracker instance used to track the\r\n   *     element.\r\n   * @param {object} opt_options Optional configuration to the tracker.\r\n   * @private\r\n   */\r\n  window.tracking.trackVideo_ = function(element, tracker) {\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n    var width;\r\n    var height;\r\n\r\n    var resizeCanvas_ = function() {\r\n      width = element.offsetWidth;\r\n      height = element.offsetHeight;\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n    };\r\n    resizeCanvas_();\r\n    element.addEventListener('resize', resizeCanvas_);\r\n\r\n    var requestId;\r\n    var stopRequestAnimationFrame = false;\r\n    var requestAnimationFrame_ = function() {\r\n      if(stopRequestAnimationFrame){\r\n        return;\r\n      }\r\n      requestId = window.requestAnimationFrame(function() {\r\n        if (element.readyState === element.HAVE_ENOUGH_DATA) {\r\n          try {\r\n            // Firefox v~30.0 gets confused with the video readyState firing an\r\n            // erroneous HAVE_ENOUGH_DATA just before HAVE_CURRENT_DATA state,\r\n            // hence keep trying to read it until resolved.\r\n            context.drawImage(element, 0, 0, width, height);\r\n          } catch (err) {}\r\n          window.tracking.trackCanvasInternal_(canvas, tracker);\r\n        }\r\n        requestAnimationFrame_();\r\n      });\r\n    };\r\n\r\n    var task = new window.tracking.TrackerTask(tracker);\r\n    task.on('stop', function() {\r\n      stopRequestAnimationFrame = true;\r\n      window.cancelAnimationFrame(requestId);\r\n    });\r\n    task.on('run', function() {\r\n      // setTimeout(() => {\r\n        stopRequestAnimationFrame = false;\r\n        requestAnimationFrame_();\r\n      // }, 3000);\r\n    });\r\n    task.on('stopVideoFeed', function() {\r\n      element.srcObject.getVideoTracks()[0].stop();\r\n    });\r\n\r\n    return task.run();\r\n  };\r\n\r\n  // Browser polyfills\r\n  //===================\r\n\r\n  if (!window.URL) {\r\n    window.URL = window.URL || window.webkitURL || window.msURL || window.oURL;\r\n  }\r\n\r\n  if (!navigator.getUserMedia) {\r\n    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||\r\n    navigator.mozGetUserMedia || navigator.msGetUserMedia;\r\n  }\r\n}(window));\r\n\r\n(function() {\r\n  /**\r\n   * EventEmitter utility.\r\n   * @constructor\r\n   */\r\n  window.tracking.EventEmitter = function() {};\r\n\r\n  /**\r\n   * Holds event listeners scoped by event type.\r\n   * @type {object}\r\n   * @private\r\n   */\r\n  window.tracking.EventEmitter.prototype.events_ = null;\r\n\r\n  /**\r\n   * Adds a listener to the end of the listeners array for the specified event.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  window.tracking.EventEmitter.prototype.addListener = function(event, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new TypeError('Listener must be a function');\r\n    }\r\n    if (!this.events_) {\r\n      this.events_ = {};\r\n    }\r\n\r\n    this.emit('newListener', event, listener);\r\n\r\n    if (!this.events_[event]) {\r\n      this.events_[event] = [];\r\n    }\r\n\r\n    this.events_[event].push(listener);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Returns an array of listeners for the specified event.\r\n   * @param {string} event\r\n   * @return {array} Array of listeners.\r\n   */\r\n  window.tracking.EventEmitter.prototype.listeners = function(event) {\r\n    return this.events_ && this.events_[event];\r\n  };\r\n\r\n  /**\r\n   * Execute each of the listeners in order with the supplied arguments.\r\n   * @param {string} event\r\n   * @param {*} opt_args [arg1], [arg2], [...]\r\n   * @return {boolean} Returns true if event had listeners, false otherwise.\r\n   */\r\n  window.tracking.EventEmitter.prototype.emit = function(event) {\r\n    var listeners = this.listeners(event);\r\n    if (listeners) {\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      for (var i = 0; i < listeners.length; i++) {\r\n        if (listeners[i]) {\r\n          listeners[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Adds a listener to the end of the listeners array for the specified event.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  window.tracking.EventEmitter.prototype.on = window.tracking.EventEmitter.prototype.addListener;\r\n\r\n  /**\r\n   * Adds a one time listener for the event. This listener is invoked only the\r\n   * next time the event is fired, after which it is removed.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  window.tracking.EventEmitter.prototype.once = function(event, listener) {\r\n    var self = this;\r\n    self.on(event, function handlerInternal() {\r\n      self.removeListener(event, handlerInternal);\r\n      listener.apply(this, arguments);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Removes all listeners, or those of the specified event. It's not a good\r\n   * idea to remove listeners that were added elsewhere in the code,\r\n   * especially when it's on an emitter that you didn't create.\r\n   * @param {string} event\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  window.tracking.EventEmitter.prototype.removeAllListeners = function(opt_event) {\r\n    if (!this.events_) {\r\n      return this;\r\n    }\r\n    if (opt_event) {\r\n      delete this.events_[opt_event];\r\n    } else {\r\n      delete this.events_;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Remove a listener from the listener array for the specified event.\r\n   * Caution: changes array indices in the listener array behind the listener.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  window.tracking.EventEmitter.prototype.removeListener = function(event, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new TypeError('Listener must be a function');\r\n    }\r\n    if (!this.events_) {\r\n      return this;\r\n    }\r\n\r\n    var listeners = this.listeners(event);\r\n    if (Array.isArray(listeners)) {\r\n      var i = listeners.indexOf(listener);\r\n      if (i < 0) {\r\n        return this;\r\n      }\r\n      listeners.splice(i, 1);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * By default EventEmitters will print a warning if more than 10 listeners\r\n   * are added for a particular event. This is a useful default which helps\r\n   * finding memory leaks. Obviously not all Emitters should be limited to 10.\r\n   * This function allows that to be increased. Set to zero for unlimited.\r\n   * @param {number} n The maximum number of listeners.\r\n   */\r\n  window.tracking.EventEmitter.prototype.setMaxListeners = function() {\r\n    throw new Error('Not implemented');\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Canvas utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.Canvas = {};\r\n\r\n  /**\r\n   * Loads an image source into the canvas.\r\n   * @param {HTMLCanvasElement} canvas The canvas dom element.\r\n   * @param {string} src The image source.\r\n   * @param {number} x The canvas horizontal coordinate to load the image.\r\n   * @param {number} y The canvas vertical coordinate to load the image.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {function} opt_callback Callback that fires when the image is loaded\r\n   *     into the canvas.\r\n   * @static\r\n   */\r\n  window.tracking.Canvas.loadImage = function(canvas, src, x, y, width, height, opt_callback) {\r\n    var instance = this;\r\n    var img = new window.Image();\r\n    img.crossOrigin = '*';\r\n    img.onload = function() {\r\n      var context = canvas.getContext('2d');\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      context.drawImage(img, x, y, width, height);\r\n      if (opt_callback) {\r\n        opt_callback.call(instance);\r\n      }\r\n      img = null;\r\n    };\r\n    img.src = src;\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * DisjointSet utility with path compression. Some applications involve\r\n   * grouping n distinct objects into a collection of disjoint sets. Two\r\n   * important operations are then finding which set a given object belongs to\r\n   * and uniting the two sets. A disjoint set data structure maintains a\r\n   * collection S={ S1 , S2 ,..., Sk } of disjoint dynamic sets. Each set is\r\n   * identified by a representative, which usually is a member in the set.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.DisjointSet = function(length) {\r\n    if (length === undefined) {\r\n      throw new Error('DisjointSet length not specified.');\r\n    }\r\n    this.length = length;\r\n    this.parent = new Uint32Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n      this.parent[i] = i;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Holds the length of the internal set.\r\n   * @type {number}\r\n   */\r\n  window.tracking.DisjointSet.prototype.length = null;\r\n\r\n  /**\r\n   * Holds the set containing the representative values.\r\n   * @type {Array.<number>}\r\n   */\r\n  window.tracking.DisjointSet.prototype.parent = null;\r\n\r\n  /**\r\n   * Finds a pointer to the representative of the set containing i.\r\n   * @param {number} i\r\n   * @return {number} The representative set of i.\r\n   */\r\n  window.tracking.DisjointSet.prototype.find = function(i) {\r\n    if (this.parent[i] === i) {\r\n      return i;\r\n    } else {\r\n      return (this.parent[i] = this.find(this.parent[i]));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unites two dynamic sets containing objects i and j, say Si and Sj, into\r\n   * a new set that Si ∪ Sj, assuming that Si ∩ Sj = ∅;\r\n   * @param {number} i\r\n   * @param {number} j\r\n   */\r\n  window.tracking.DisjointSet.prototype.union = function(i, j) {\r\n    var iRepresentative = this.find(i);\r\n    var jRepresentative = this.find(j);\r\n    this.parent[iRepresentative] = jRepresentative;\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Image utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.Image = {};\r\n\r\n  /**\r\n   * Computes gaussian blur. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} diameter Gaussian blur diameter, must be greater than 1.\r\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  window.tracking.Image.blur = function(pixels, width, height, diameter) {\r\n    diameter = Math.abs(diameter);\r\n    if (diameter <= 1) {\r\n      throw new Error('Diameter should be greater than 1.');\r\n    }\r\n    var radius = diameter / 2;\r\n    var len = Math.ceil(diameter) + (1 - (Math.ceil(diameter) % 2));\r\n    var weights = new Float32Array(len);\r\n    var rho = (radius + 0.5) / 3;\r\n    var rhoSq = rho * rho;\r\n    var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\r\n    var rhoFactor = -1 / (2 * rho * rho);\r\n    var wsum = 0;\r\n    var middle = Math.floor(len / 2);\r\n    for (var i = 0; i < len; i++) {\r\n      var x = i - middle;\r\n      var gx = gaussianFactor * Math.exp(x * x * rhoFactor);\r\n      weights[i] = gx;\r\n      wsum += gx;\r\n    }\r\n    for (var j = 0; j < weights.length; j++) {\r\n      weights[j] /= wsum;\r\n    }\r\n    return this.separableConvolve(pixels, width, height, weights, weights, false);\r\n  };\r\n\r\n  /**\r\n   * Computes the integral image for summed, squared, rotated and sobel pixels.\r\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\r\n   *     through.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} opt_integralImage Empty array of size `width * height` to\r\n   *     be filled with the integral image values. If not specified compute sum\r\n   *     values will be skipped.\r\n   * @param {array} opt_integralImageSquare Empty array of size `width *\r\n   *     height` to be filled with the integral image squared values. If not\r\n   *     specified compute squared values will be skipped.\r\n   * @param {array} opt_tiltedIntegralImage Empty array of size `width *\r\n   *     height` to be filled with the rotated integral image values. If not\r\n   *     specified compute sum values will be skipped.\r\n   * @param {array} opt_integralImageSobel Empty array of size `width *\r\n   *     height` to be filled with the integral image of sobel values. If not\r\n   *     specified compute sobel filtering will be skipped.\r\n   * @static\r\n   */\r\n  window.tracking.Image.computeIntegralImage = function(pixels, width, height, opt_integralImage, opt_integralImageSquare, opt_tiltedIntegralImage, opt_integralImageSobel) {\r\n    if (arguments.length < 4) {\r\n      throw new Error('You should specify at least one output array in the order: sum, square, tilted, sobel.');\r\n    }\r\n    var pixelsSobel;\r\n    if (opt_integralImageSobel) {\r\n      pixelsSobel = window.tracking.Image.sobel(pixels, width, height);\r\n    }\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var w = i * width * 4 + j * 4;\r\n        var pixel = ~~(pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114);\r\n        if (opt_integralImage) {\r\n          this.computePixelValueSAT_(opt_integralImage, width, i, j, pixel);\r\n        }\r\n        if (opt_integralImageSquare) {\r\n          this.computePixelValueSAT_(opt_integralImageSquare, width, i, j, pixel * pixel);\r\n        }\r\n        if (opt_tiltedIntegralImage) {\r\n          var w1 = w - width * 4;\r\n          var pixelAbove = ~~(pixels[w1] * 0.299 + pixels[w1 + 1] * 0.587 + pixels[w1 + 2] * 0.114);\r\n          this.computePixelValueRSAT_(opt_tiltedIntegralImage, width, i, j, pixel, pixelAbove || 0);\r\n        }\r\n        if (opt_integralImageSobel) {\r\n          this.computePixelValueSAT_(opt_integralImageSobel, width, i, j, pixelsSobel[w]);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Helper method to compute the rotated summed area table (RSAT) by the\r\n   * formula:\r\n   *\r\n   * RSAT(x, y) = RSAT(x-1, y-1) + RSAT(x+1, y-1) - RSAT(x, y-2) + I(x, y) + I(x, y-1)\r\n   *\r\n   * @param {number} width The image width.\r\n   * @param {array} RSAT Empty array of size `width * height` to be filled with\r\n   *     the integral image values. If not specified compute sum values will be\r\n   *     skipped.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} pixel Pixel value to be added to the integral image.\r\n   * @static\r\n   * @private\r\n   */\r\n  window.tracking.Image.computePixelValueRSAT_ = function(RSAT, width, i, j, pixel, pixelAbove) {\r\n    var w = i * width + j;\r\n    RSAT[w] = (RSAT[w - width - 1] || 0) + (RSAT[w - width + 1] || 0) - (RSAT[w - width - width] || 0) + pixel + pixelAbove;\r\n  };\r\n\r\n  /**\r\n   * Helper method to compute the summed area table (SAT) by the formula:\r\n   *\r\n   * SAT(x, y) = SAT(x, y-1) + SAT(x-1, y) + I(x, y) - SAT(x-1, y-1)\r\n   *\r\n   * @param {number} width The image width.\r\n   * @param {array} SAT Empty array of size `width * height` to be filled with\r\n   *     the integral image values. If not specified compute sum values will be\r\n   *     skipped.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} pixel Pixel value to be added to the integral image.\r\n   * @static\r\n   * @private\r\n   */\r\n  window.tracking.Image.computePixelValueSAT_ = function(SAT, width, i, j, pixel) {\r\n    var w = i * width + j;\r\n    SAT[w] = (SAT[w - width] || 0) + (SAT[w - 1] || 0) + pixel - (SAT[w - width - 1] || 0);\r\n  };\r\n\r\n  /**\r\n   * Converts a color from a colorspace based on an RGB color model to a\r\n   * grayscale representation of its luminance. The coefficients represent the\r\n   * measured intensity perception of typical trichromat humans, in\r\n   * particular, human vision is most sensitive to green and least sensitive\r\n   * to blue.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {boolean} fillRGBA If the result should fill all RGBA values with the gray scale\r\n   *  values, instead of returning a single value per pixel.\r\n   * @param {Uint8ClampedArray} The grayscale pixels in a linear array ([p,p,p,a,...] if fillRGBA\r\n   *  is true and [p1, p2, p3, ...] if fillRGBA is false).\r\n   * @static\r\n   */\r\n  window.tracking.Image.grayscale = function(pixels, width, height, fillRGBA) {\r\n    var gray = new Uint8ClampedArray(fillRGBA ? pixels.length : pixels.length >> 2);\r\n    var p = 0;\r\n    var w = 0;\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var value = pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114;\r\n        gray[p++] = value;\r\n\r\n        if (fillRGBA) {\r\n          gray[p++] = value;\r\n          gray[p++] = value;\r\n          gray[p++] = pixels[w + 3];\r\n        }\r\n\r\n        w += 4;\r\n      }\r\n    }\r\n    return gray;\r\n  };\r\n\r\n  /**\r\n   * Fast horizontal separable convolution. A point spread function (PSF) is\r\n   * said to be separable if it can be broken into two one-dimensional\r\n   * signals: a vertical and a horizontal projection. The convolution is\r\n   * performed by sliding the kernel over the image, generally starting at the\r\n   * top left corner, so as to move the kernel through all the positions where\r\n   * the kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  window.tracking.Image.horizontalConvolve = function(pixels, width, height, weightsVector, opaque) {\r\n    var side = weightsVector.length;\r\n    var halfSide = Math.floor(side / 2);\r\n    var output = new Float32Array(width * height * 4);\r\n    var alphaFac = opaque ? 1 : 0;\r\n\r\n    for (var y = 0; y < height; y++) {\r\n      for (var x = 0; x < width; x++) {\r\n        var sy = y;\r\n        var sx = x;\r\n        var offset = (y * width + x) * 4;\r\n        var r = 0;\r\n        var g = 0;\r\n        var b = 0;\r\n        var a = 0;\r\n        for (var cx = 0; cx < side; cx++) {\r\n          var scy = sy;\r\n          var scx = Math.min(width - 1, Math.max(0, sx + cx - halfSide));\r\n          var poffset = (scy * width + scx) * 4;\r\n          var wt = weightsVector[cx];\r\n          r += pixels[poffset] * wt;\r\n          g += pixels[poffset + 1] * wt;\r\n          b += pixels[poffset + 2] * wt;\r\n          a += pixels[poffset + 3] * wt;\r\n        }\r\n        output[offset] = r;\r\n        output[offset + 1] = g;\r\n        output[offset + 2] = b;\r\n        output[offset + 3] = a + alphaFac * (255 - a);\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * Fast vertical separable convolution. A point spread function (PSF) is\r\n   * said to be separable if it can be broken into two one-dimensional\r\n   * signals: a vertical and a horizontal projection. The convolution is\r\n   * performed by sliding the kernel over the image, generally starting at the\r\n   * top left corner, so as to move the kernel through all the positions where\r\n   * the kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  window.tracking.Image.verticalConvolve = function(pixels, width, height, weightsVector, opaque) {\r\n    var side = weightsVector.length;\r\n    var halfSide = Math.floor(side / 2);\r\n    var output = new Float32Array(width * height * 4);\r\n    var alphaFac = opaque ? 1 : 0;\r\n\r\n    for (var y = 0; y < height; y++) {\r\n      for (var x = 0; x < width; x++) {\r\n        var sy = y;\r\n        var sx = x;\r\n        var offset = (y * width + x) * 4;\r\n        var r = 0;\r\n        var g = 0;\r\n        var b = 0;\r\n        var a = 0;\r\n        for (var cy = 0; cy < side; cy++) {\r\n          var scy = Math.min(height - 1, Math.max(0, sy + cy - halfSide));\r\n          var scx = sx;\r\n          var poffset = (scy * width + scx) * 4;\r\n          var wt = weightsVector[cy];\r\n          r += pixels[poffset] * wt;\r\n          g += pixels[poffset + 1] * wt;\r\n          b += pixels[poffset + 2] * wt;\r\n          a += pixels[poffset + 3] * wt;\r\n        }\r\n        output[offset] = r;\r\n        output[offset + 1] = g;\r\n        output[offset + 2] = b;\r\n        output[offset + 3] = a + alphaFac * (255 - a);\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * Fast separable convolution. A point spread function (PSF) is said to be\r\n   * separable if it can be broken into two one-dimensional signals: a\r\n   * vertical and a horizontal projection. The convolution is performed by\r\n   * sliding the kernel over the image, generally starting at the top left\r\n   * corner, so as to move the kernel through all the positions where the\r\n   * kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} horizWeights The horizontal weighting vector, e.g [-1,0,1].\r\n   * @param {array} vertWeights The vertical vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  window.tracking.Image.separableConvolve = function(pixels, width, height, horizWeights, vertWeights, opaque) {\r\n    var vertical = this.verticalConvolve(pixels, width, height, vertWeights, opaque);\r\n    return this.horizontalConvolve(vertical, width, height, horizWeights, opaque);\r\n  };\r\n\r\n  /**\r\n   * Compute image edges using Sobel operator. Computes the vertical and\r\n   * horizontal gradients of the image and combines the computed images to\r\n   * find edges in the image. The way we implement the Sobel filter here is by\r\n   * first grayscaling the image, then taking the horizontal and vertical\r\n   * gradients and finally combining the gradient images to make up the final\r\n   * image. Adapted from https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  window.tracking.Image.sobel = function(pixels, width, height) {\r\n    pixels = this.grayscale(pixels, width, height, true);\r\n    var output = new Float32Array(width * height * 4);\r\n    var sobelSignVector = new Float32Array([-1, 0, 1]);\r\n    var sobelScaleVector = new Float32Array([1, 2, 1]);\r\n    var vertical = this.separableConvolve(pixels, width, height, sobelSignVector, sobelScaleVector);\r\n    var horizontal = this.separableConvolve(pixels, width, height, sobelScaleVector, sobelSignVector);\r\n\r\n    for (var i = 0; i < output.length; i += 4) {\r\n      var v = vertical[i];\r\n      var h = horizontal[i];\r\n      var p = Math.sqrt(h * h + v * v);\r\n      output[i] = p;\r\n      output[i + 1] = p;\r\n      output[i + 2] = p;\r\n      output[i + 3] = 255;\r\n    }\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * Equalizes the histogram of a grayscale image, normalizing the\r\n   * brightness and increasing the contrast of the image.\r\n   * @param {pixels} pixels The grayscale pixels in a linear array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @return {array} The equalized grayscale pixels in a linear array.\r\n   */\r\n  window.tracking.Image.equalizeHist = function(pixels, width, height){\r\n    var equalized = new Uint8ClampedArray(pixels.length);\r\n\r\n    var histogram = new Array(256);\r\n    for(var i=0; i < 256; i++) histogram[i] = 0;\r\n\r\n    for(var i=0; i < pixels.length; i++){\r\n      equalized[i] = pixels[i];\r\n      histogram[pixels[i]]++;\r\n    }\r\n\r\n    var prev = histogram[0];\r\n    for(var i=0; i < 256; i++){\r\n      histogram[i] += prev;\r\n      prev = histogram[i];\r\n    }\r\n\r\n    var norm = 255 / pixels.length;\r\n    for(var i=0; i < pixels.length; i++)\r\n      equalized[i] = (histogram[pixels[i]] * norm + 0.5) | 0;\r\n\r\n    return equalized;\r\n  }\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * ViolaJones utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.ViolaJones = {};\r\n\r\n  /**\r\n   * Holds the minimum area of intersection that defines when a rectangle is\r\n   * from the same group. Often when a face is matched multiple rectangles are\r\n   * classified as possible rectangles to represent the face, when they\r\n   * intersects they are grouped as one face.\r\n   * @type {number}\r\n   * @default 0.5\r\n   * @static\r\n   */\r\n  window.tracking.ViolaJones.REGIONS_OVERLAP = 0.5;\r\n\r\n  /**\r\n   * Holds the HAAR cascade classifiers converted from OpenCV training.\r\n   * @type {array}\r\n   * @static\r\n   */\r\n  window.tracking.ViolaJones.classifiers = {};\r\n\r\n  /**\r\n   * Detects through the HAAR cascade data rectangles matches.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} initialScale The initial scale to start the block\r\n   *     scaling.\r\n   * @param {number} scaleFactor The scale factor to scale the feature block.\r\n   * @param {number} stepSize The block step size.\r\n   * @param {number} edgesDensity Percentage density edges inside the\r\n   *     classifier block. Value from [0.0, 1.0], defaults to 0.2. If specified\r\n   *     edge detection will be applied to the image to prune dead areas of the\r\n   *     image, this can improve significantly performance.\r\n   * @param {number} data The HAAR cascade data.\r\n   * @return {array} Found rectangles.\r\n   * @static\r\n   */\r\n  window.tracking.ViolaJones.detect = function(pixels, width, height, initialScale, scaleFactor, stepSize, edgesDensity, data) {\r\n    var total = 0;\r\n    var rects = [];\r\n    var integralImage = new Int32Array(width * height);\r\n    var integralImageSquare = new Int32Array(width * height);\r\n    var tiltedIntegralImage = new Int32Array(width * height);\r\n\r\n    var integralImageSobel;\r\n    if (edgesDensity > 0) {\r\n      integralImageSobel = new Int32Array(width * height);\r\n    }\r\n\r\n    window.tracking.Image.computeIntegralImage(pixels, width, height, integralImage, integralImageSquare, tiltedIntegralImage, integralImageSobel);\r\n\r\n    var minWidth = data[0];\r\n    var minHeight = data[1];\r\n    var scale = initialScale * scaleFactor;\r\n    var blockWidth = (scale * minWidth) | 0;\r\n    var blockHeight = (scale * minHeight) | 0;\r\n\r\n    while (blockWidth < width && blockHeight < height) {\r\n      var step = (scale * stepSize + 0.5) | 0;\r\n      for (var i = 0; i < (height - blockHeight); i += step) {\r\n        for (var j = 0; j < (width - blockWidth); j += step) {\r\n\r\n          if (edgesDensity > 0) {\r\n            if (this.isTriviallyExcluded(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight)) {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (this.evalStages_(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale)) {\r\n            rects[total++] = {\r\n              width: blockWidth,\r\n              height: blockHeight,\r\n              x: j,\r\n              y: i\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      scale *= scaleFactor;\r\n      blockWidth = (scale * minWidth) | 0;\r\n      blockHeight = (scale * minHeight) | 0;\r\n    }\r\n    return this.mergeRectangles_(rects);\r\n  };\r\n\r\n  /**\r\n   * Fast check to test whether the edges density inside the block is greater\r\n   * than a threshold, if true it tests the stages. This can improve\r\n   * significantly performance.\r\n   * @param {number} edgesDensity Percentage density edges inside the\r\n   *     classifier block.\r\n   * @param {array} integralImageSobel The integral image of a sobel image.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} width The image width.\r\n   * @return {boolean} True whether the block at position i,j can be skipped,\r\n   *     false otherwise.\r\n   * @static\r\n   * @protected\r\n   */\r\n  window.tracking.ViolaJones.isTriviallyExcluded = function(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight) {\r\n    var wbA = i * width + j;\r\n    var wbB = wbA + blockWidth;\r\n    var wbD = wbA + blockHeight * width;\r\n    var wbC = wbD + blockWidth;\r\n    var blockEdgesDensity = (integralImageSobel[wbA] - integralImageSobel[wbB] - integralImageSobel[wbD] + integralImageSobel[wbC]) / (blockWidth * blockHeight * 255);\r\n    if (blockEdgesDensity < edgesDensity) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Evaluates if the block size on i,j position is a valid HAAR cascade\r\n   * stage.\r\n   * @param {number} data The HAAR cascade data.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} width The image width.\r\n   * @param {number} blockSize The block size.\r\n   * @param {number} scale The scale factor of the block size and its original\r\n   *     size.\r\n   * @param {number} inverseArea The inverse area of the block size.\r\n   * @return {boolean} Whether the region passes all the stage tests.\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.ViolaJones.evalStages_ = function(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale) {\r\n    var inverseArea = 1.0 / (blockWidth * blockHeight);\r\n    var wbA = i * width + j;\r\n    var wbB = wbA + blockWidth;\r\n    var wbD = wbA + blockHeight * width;\r\n    var wbC = wbD + blockWidth;\r\n    var mean = (integralImage[wbA] - integralImage[wbB] - integralImage[wbD] + integralImage[wbC]) * inverseArea;\r\n    var variance = (integralImageSquare[wbA] - integralImageSquare[wbB] - integralImageSquare[wbD] + integralImageSquare[wbC]) * inverseArea - mean * mean;\r\n\r\n    var standardDeviation = 1;\r\n    if (variance > 0) {\r\n      standardDeviation = Math.sqrt(variance);\r\n    }\r\n\r\n    var length = data.length;\r\n\r\n    for (var w = 2; w < length; ) {\r\n      var stageSum = 0;\r\n      var stageThreshold = data[w++];\r\n      var nodeLength = data[w++];\r\n\r\n      while (nodeLength--) {\r\n        var rectsSum = 0;\r\n        var tilted = data[w++];\r\n        var rectsLength = data[w++];\r\n\r\n        for (var r = 0; r < rectsLength; r++) {\r\n          var rectLeft = (j + data[w++] * scale + 0.5) | 0;\r\n          var rectTop = (i + data[w++] * scale + 0.5) | 0;\r\n          var rectWidth = (data[w++] * scale + 0.5) | 0;\r\n          var rectHeight = (data[w++] * scale + 0.5) | 0;\r\n          var rectWeight = data[w++];\r\n\r\n          var w1;\r\n          var w2;\r\n          var w3;\r\n          var w4;\r\n          if (tilted) {\r\n            // RectSum(r) = RSAT(x-h+w, y+w+h-1) + RSAT(x, y-1) - RSAT(x-h, y+h-1) - RSAT(x+w, y+w-1)\r\n            w1 = (rectLeft - rectHeight + rectWidth) + (rectTop + rectWidth + rectHeight - 1) * width;\r\n            w2 = rectLeft + (rectTop - 1) * width;\r\n            w3 = (rectLeft - rectHeight) + (rectTop + rectHeight - 1) * width;\r\n            w4 = (rectLeft + rectWidth) + (rectTop + rectWidth - 1) * width;\r\n            rectsSum += (tiltedIntegralImage[w1] + tiltedIntegralImage[w2] - tiltedIntegralImage[w3] - tiltedIntegralImage[w4]) * rectWeight;\r\n          } else {\r\n            // RectSum(r) = SAT(x-1, y-1) + SAT(x+w-1, y+h-1) - SAT(x-1, y+h-1) - SAT(x+w-1, y-1)\r\n            w1 = rectTop * width + rectLeft;\r\n            w2 = w1 + rectWidth;\r\n            w3 = w1 + rectHeight * width;\r\n            w4 = w3 + rectWidth;\r\n            rectsSum += (integralImage[w1] - integralImage[w2] - integralImage[w3] + integralImage[w4]) * rectWeight;\r\n            // TODO: Review the code below to analyze performance when using it instead.\r\n            // w1 = (rectLeft - 1) + (rectTop - 1) * width;\r\n            // w2 = (rectLeft + rectWidth - 1) + (rectTop + rectHeight - 1) * width;\r\n            // w3 = (rectLeft - 1) + (rectTop + rectHeight - 1) * width;\r\n            // w4 = (rectLeft + rectWidth - 1) + (rectTop - 1) * width;\r\n            // rectsSum += (integralImage[w1] + integralImage[w2] - integralImage[w3] - integralImage[w4]) * rectWeight;\r\n          }\r\n        }\r\n\r\n        var nodeThreshold = data[w++];\r\n        var nodeLeft = data[w++];\r\n        var nodeRight = data[w++];\r\n\r\n        if (rectsSum * inverseArea < nodeThreshold * standardDeviation) {\r\n          stageSum += nodeLeft;\r\n        } else {\r\n          stageSum += nodeRight;\r\n        }\r\n      }\r\n\r\n      if (stageSum < stageThreshold) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Postprocess the detected sub-windows in order to combine overlapping\r\n   * detections into a single detection.\r\n   * @param {array} rects\r\n   * @return {array}\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.ViolaJones.mergeRectangles_ = function(rects) {\r\n    var disjointSet = new window.tracking.DisjointSet(rects.length);\r\n\r\n    for (var i = 0; i < rects.length; i++) {\r\n      var r1 = rects[i];\r\n      for (var j = 0; j < rects.length; j++) {\r\n        var r2 = rects[j];\r\n        if (window.tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\r\n          var x1 = Math.max(r1.x, r2.x);\r\n          var y1 = Math.max(r1.y, r2.y);\r\n          var x2 = Math.min(r1.x + r1.width, r2.x + r2.width);\r\n          var y2 = Math.min(r1.y + r1.height, r2.y + r2.height);\r\n          var overlap = (x1 - x2) * (y1 - y2);\r\n          var area1 = (r1.width * r1.height);\r\n          var area2 = (r2.width * r2.height);\r\n\r\n          if ((overlap / (area1 * (area1 / area2)) >= this.REGIONS_OVERLAP) &&\r\n            (overlap / (area2 * (area1 / area2)) >= this.REGIONS_OVERLAP)) {\r\n            disjointSet.union(i, j);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    var map = {};\r\n    for (var k = 0; k < disjointSet.length; k++) {\r\n      var rep = disjointSet.find(k);\r\n      if (!map[rep]) {\r\n        map[rep] = {\r\n          total: 1,\r\n          width: rects[k].width,\r\n          height: rects[k].height,\r\n          x: rects[k].x,\r\n          y: rects[k].y\r\n        };\r\n        continue;\r\n      }\r\n      map[rep].total++;\r\n      map[rep].width += rects[k].width;\r\n      map[rep].height += rects[k].height;\r\n      map[rep].x += rects[k].x;\r\n      map[rep].y += rects[k].y;\r\n    }\r\n\r\n    var result = [];\r\n    Object.keys(map).forEach(function(key) {\r\n      var rect = map[key];\r\n      result.push({\r\n        total: rect.total,\r\n        width: (rect.width / rect.total + 0.5) | 0,\r\n        height: (rect.height / rect.total + 0.5) | 0,\r\n        x: (rect.x / rect.total + 0.5) | 0,\r\n        y: (rect.y / rect.total + 0.5) | 0\r\n      });\r\n    });\r\n\r\n    return result;\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Brief intends for \"Binary Robust Independent Elementary Features\".This\r\n   * method generates a binary string for each keypoint found by an extractor\r\n   * method.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.Brief = {};\r\n\r\n  /**\r\n   * The set of binary tests is defined by the nd (x,y)-location pairs\r\n   * uniquely chosen during the initialization. Values could vary between N =\r\n   * 128,256,512. N=128 yield good compromises between speed, storage\r\n   * efficiency, and recognition rate.\r\n   * @type {number}\r\n   */\r\n  window.tracking.Brief.N = 512;\r\n\r\n  /**\r\n   * Caches coordinates values of (x,y)-location pairs uniquely chosen during\r\n   * the initialization.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.Brief.randomImageOffsets_ = {};\r\n\r\n  /**\r\n   * Caches delta values of (x,y)-location pairs uniquely chosen during\r\n   * the initialization.\r\n   * @type {Int32Array}\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.Brief.randomWindowOffsets_ = null;\r\n\r\n  /**\r\n   * Generates a binary string for each found keypoints extracted using an\r\n   * extractor method.\r\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {array} keypoints\r\n   * @return {Int32Array} Returns an array where for each four sequence int\r\n   *     values represent the descriptor binary string (128 bits) necessary\r\n   *     to describe the corner, e.g. [0,0,0,0, 0,0,0,0, ...].\r\n   * @static\r\n   */\r\n  window.tracking.Brief.getDescriptors = function(pixels, width, keypoints) {\r\n    // Optimizing divide by 32 operation using binary shift\r\n    // (this.N >> 5) === this.N/32.\r\n    var descriptors = new Int32Array((keypoints.length >> 1) * (this.N >> 5));\r\n    var descriptorWord = 0;\r\n    var offsets = this.getRandomOffsets_(width);\r\n    var position = 0;\r\n\r\n    for (var i = 0; i < keypoints.length; i += 2) {\r\n      var w = width * keypoints[i + 1] + keypoints[i];\r\n\r\n      var offsetsPosition = 0;\r\n      for (var j = 0, n = this.N; j < n; j++) {\r\n        if (pixels[offsets[offsetsPosition++] + w] < pixels[offsets[offsetsPosition++] + w]) {\r\n          // The bit in the position `j % 32` of descriptorWord should be set to 1. We do\r\n          // this by making an OR operation with a binary number that only has the bit\r\n          // in that position set to 1. That binary number is obtained by shifting 1 left by\r\n          // `j % 32` (which is the same as `j & 31` left) positions.\r\n          descriptorWord |= 1 << (j & 31);\r\n        }\r\n\r\n        // If the next j is a multiple of 32, we will need to use a new descriptor word to hold\r\n        // the next results.\r\n        if (!((j + 1) & 31)) {\r\n          descriptors[position++] = descriptorWord;\r\n          descriptorWord = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    return descriptors;\r\n  };\r\n\r\n  /**\r\n   * Matches sets of features {mi} and {m′j} extracted from two images taken\r\n   * from similar, and often successive, viewpoints. A classical procedure\r\n   * runs as follows. For each point {mi} in the first image, search in a\r\n   * region of the second image around location {mi} for point {m′j}. The\r\n   * search is based on the similarity of the local image windows, also known\r\n   * as kernel windows, centered on the points, which strongly characterizes\r\n   * the points when the images are sufficiently close. Once each keypoint is\r\n   * described with its binary string, they need to be compared with the\r\n   * closest matching point. Distance metric is critical to the performance of\r\n   * in- trusion detection systems. Thus using binary strings reduces the size\r\n   * of the descriptor and provides an interesting data structure that is fast\r\n   * to operate whose similarity can be measured by the Hamming distance.\r\n   * @param {array} keypoints1\r\n   * @param {array} descriptors1\r\n   * @param {array} keypoints2\r\n   * @param {array} descriptors2\r\n   * @return {Int32Array} Returns an array where the index is the corner1\r\n   *     index coordinate, and the value is the corresponding match index of\r\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\r\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\r\n   *     the return array would be [3,0].\r\n   * @static\r\n   */\r\n  window.tracking.Brief.match = function(keypoints1, descriptors1, keypoints2, descriptors2) {\r\n    var len1 = keypoints1.length >> 1;\r\n    var len2 = keypoints2.length >> 1;\r\n    var matches = new Array(len1);\r\n\r\n    for (var i = 0; i < len1; i++) {\r\n      var min = Infinity;\r\n      var minj = 0;\r\n      for (var j = 0; j < len2; j++) {\r\n        var dist = 0;\r\n        // Optimizing divide by 32 operation using binary shift\r\n        // (this.N >> 5) === this.N/32.\r\n        for (var k = 0, n = this.N >> 5; k < n; k++) {\r\n          dist += window.tracking.Math.hammingWeight(descriptors1[i * n + k] ^ descriptors2[j * n + k]);\r\n        }\r\n        if (dist < min) {\r\n          min = dist;\r\n          minj = j;\r\n        }\r\n      }\r\n      matches[i] = {\r\n        index1: i,\r\n        index2: minj,\r\n        keypoint1: [keypoints1[2 * i], keypoints1[2 * i + 1]],\r\n        keypoint2: [keypoints2[2 * minj], keypoints2[2 * minj + 1]],\r\n        confidence: 1 - min / this.N\r\n      };\r\n    }\r\n\r\n    return matches;\r\n  };\r\n\r\n  /**\r\n   * Removes matches outliers by testing matches on both directions.\r\n   * @param {array} keypoints1\r\n   * @param {array} descriptors1\r\n   * @param {array} keypoints2\r\n   * @param {array} descriptors2\r\n   * @return {Int32Array} Returns an array where the index is the corner1\r\n   *     index coordinate, and the value is the corresponding match index of\r\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\r\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\r\n   *     the return array would be [3,0].\r\n   * @static\r\n   */\r\n  window.tracking.Brief.reciprocalMatch = function(keypoints1, descriptors1, keypoints2, descriptors2) {\r\n    var matches = [];\r\n    if (keypoints1.length === 0 || keypoints2.length === 0) {\r\n      return matches;\r\n    }\r\n\r\n    var matches1 = window.tracking.Brief.match(keypoints1, descriptors1, keypoints2, descriptors2);\r\n    var matches2 = window.tracking.Brief.match(keypoints2, descriptors2, keypoints1, descriptors1);\r\n    for (var i = 0; i < matches1.length; i++) {\r\n      if (matches2[matches1[i].index2].index2 === i) {\r\n        matches.push(matches1[i]);\r\n      }\r\n    }\r\n    return matches;\r\n  };\r\n\r\n  /**\r\n   * Gets the coordinates values of (x,y)-location pairs uniquely chosen\r\n   * during the initialization.\r\n   * @return {array} Array with the random offset values.\r\n   * @private\r\n   */\r\n  window.tracking.Brief.getRandomOffsets_ = function(width) {\r\n    if (!this.randomWindowOffsets_) {\r\n      var windowPosition = 0;\r\n      var windowOffsets = new Int32Array(4 * this.N);\r\n      for (var i = 0; i < this.N; i++) {\r\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\r\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\r\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\r\n        windowOffsets[windowPosition++] = Math.round(window.tracking.Math.uniformRandom(-15, 16));\r\n      }\r\n      this.randomWindowOffsets_ = windowOffsets;\r\n    }\r\n\r\n    if (!this.randomImageOffsets_[width]) {\r\n      var imagePosition = 0;\r\n      var imageOffsets = new Int32Array(2 * this.N);\r\n      for (var j = 0; j < this.N; j++) {\r\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j] * width + this.randomWindowOffsets_[4 * j + 1];\r\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j + 2] * width + this.randomWindowOffsets_[4 * j + 3];\r\n      }\r\n      this.randomImageOffsets_[width] = imageOffsets;\r\n    }\r\n\r\n    return this.randomImageOffsets_[width];\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * FAST intends for \"Features from Accelerated Segment Test\". This method\r\n   * performs a point segment test corner detection. The segment test\r\n   * criterion operates by considering a circle of sixteen pixels around the\r\n   * corner candidate p. The detector classifies p as a corner if there exists\r\n   * a set of n contiguous pixelsin the circle which are all brighter than the\r\n   * intensity of the candidate pixel Ip plus a threshold t, or all darker\r\n   * than Ip − t.\r\n   *\r\n   *       15 00 01\r\n   *    14          02\r\n   * 13                03\r\n   * 12       []       04\r\n   * 11                05\r\n   *    10          06\r\n   *       09 08 07\r\n   *\r\n   * For more reference:\r\n   * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.3991&rep=rep1&type=pdf\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.Fast = {};\r\n\r\n  /**\r\n   * Holds the threshold to determine whether the tested pixel is brighter or\r\n   * darker than the corner candidate p.\r\n   * @type {number}\r\n   * @default 40\r\n   * @static\r\n   */\r\n  window.tracking.Fast.THRESHOLD = 40;\r\n\r\n  /**\r\n   * Caches coordinates values of the circle surrounding the pixel candidate p.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.Fast.circles_ = {};\r\n\r\n  /**\r\n   * Finds corners coordinates on the graysacaled image.\r\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} threshold to determine whether the tested pixel is brighter or\r\n   *     darker than the corner candidate p. Default value is 40.\r\n   * @return {array} Array containing the coordinates of all found corners,\r\n   *     e.g. [x0,y0,x1,y1,...], where P(x0,y0) represents a corner coordinate.\r\n   * @static\r\n   */\r\n  window.tracking.Fast.findCorners = function(pixels, width, height, opt_threshold) {\r\n    var circleOffsets = this.getCircleOffsets_(width);\r\n    var circlePixels = new Int32Array(16);\r\n    var corners = [];\r\n\r\n    if (opt_threshold === undefined) {\r\n      opt_threshold = this.THRESHOLD;\r\n    }\r\n\r\n    // When looping through the image pixels, skips the first three lines from\r\n    // the image boundaries to constrain the surrounding circle inside the image\r\n    // area.\r\n    for (var i = 3; i < height - 3; i++) {\r\n      for (var j = 3; j < width - 3; j++) {\r\n        var w = i * width + j;\r\n        var p = pixels[w];\r\n\r\n        // Loops the circle offsets to read the pixel value for the sixteen\r\n        // surrounding pixels.\r\n        for (var k = 0; k < 16; k++) {\r\n          circlePixels[k] = pixels[w + circleOffsets[k]];\r\n        }\r\n\r\n        if (this.isCorner(p, circlePixels, opt_threshold)) {\r\n          // The pixel p is classified as a corner, as optimization increment j\r\n          // by the circle radius 3 to skip the neighbor pixels inside the\r\n          // surrounding circle. This can be removed without compromising the\r\n          // result.\r\n          corners.push(j, i);\r\n          j += 3;\r\n        }\r\n      }\r\n    }\r\n\r\n    return corners;\r\n  };\r\n\r\n  /**\r\n   * Checks if the circle pixel is brighter than the candidate pixel p by\r\n   * a threshold.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\r\n  window.tracking.Fast.isBrighter = function(circlePixel, p, threshold) {\r\n    return circlePixel - p > threshold;\r\n  };\r\n\r\n  /**\r\n   * Checks if the circle pixel is within the corner of the candidate pixel p\r\n   * by a threshold.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\r\n  window.tracking.Fast.isCorner = function(p, circlePixels, threshold) {\r\n    if (this.isTriviallyExcluded(circlePixels, p, threshold)) {\r\n      return false;\r\n    }\r\n\r\n    for (var x = 0; x < 16; x++) {\r\n      var darker = true;\r\n      var brighter = true;\r\n\r\n      for (var y = 0; y < 9; y++) {\r\n        var circlePixel = circlePixels[(x + y) & 15];\r\n\r\n        if (!this.isBrighter(p, circlePixel, threshold)) {\r\n          brighter = false;\r\n          if (darker === false) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!this.isDarker(p, circlePixel, threshold)) {\r\n          darker = false;\r\n          if (brighter === false) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (brighter || darker) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Checks if the circle pixel is darker than the candidate pixel p by\r\n   * a threshold.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\r\n  window.tracking.Fast.isDarker = function(circlePixel, p, threshold) {\r\n    return p - circlePixel > threshold;\r\n  };\r\n\r\n  /**\r\n   * Fast check to test if the candidate pixel is a trivially excluded value.\r\n   * In order to be a corner, the candidate pixel value should be darker or\r\n   * brighter than 9-12 surrounding pixels, when at least three of the top,\r\n   * bottom, left and right pixels are brighter or darker it can be\r\n   * automatically excluded improving the performance.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   * @protected\r\n   */\r\n  window.tracking.Fast.isTriviallyExcluded = function(circlePixels, p, threshold) {\r\n    var count = 0;\r\n    var circleBottom = circlePixels[8];\r\n    var circleLeft = circlePixels[12];\r\n    var circleRight = circlePixels[4];\r\n    var circleTop = circlePixels[0];\r\n\r\n    if (this.isBrighter(circleTop, p, threshold)) {\r\n      count++;\r\n    }\r\n    if (this.isBrighter(circleRight, p, threshold)) {\r\n      count++;\r\n    }\r\n    if (this.isBrighter(circleBottom, p, threshold)) {\r\n      count++;\r\n    }\r\n    if (this.isBrighter(circleLeft, p, threshold)) {\r\n      count++;\r\n    }\r\n\r\n    if (count < 3) {\r\n      count = 0;\r\n      if (this.isDarker(circleTop, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (this.isDarker(circleRight, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (this.isDarker(circleBottom, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (this.isDarker(circleLeft, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (count < 3) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Gets the sixteen offset values of the circle surrounding pixel.\r\n   * @param {number} width The image width.\r\n   * @return {array} Array with the sixteen offset values of the circle\r\n   *     surrounding pixel.\r\n   * @private\r\n   */\r\n  window.tracking.Fast.getCircleOffsets_ = function(width) {\r\n    if (this.circles_[width]) {\r\n      return this.circles_[width];\r\n    }\r\n\r\n    var circle = new Int32Array(16);\r\n\r\n    circle[0] = -width - width - width;\r\n    circle[1] = circle[0] + 1;\r\n    circle[2] = circle[1] + width + 1;\r\n    circle[3] = circle[2] + width + 1;\r\n    circle[4] = circle[3] + width;\r\n    circle[5] = circle[4] + width;\r\n    circle[6] = circle[5] + width - 1;\r\n    circle[7] = circle[6] + width - 1;\r\n    circle[8] = circle[7] - 1;\r\n    circle[9] = circle[8] - 1;\r\n    circle[10] = circle[9] - width - 1;\r\n    circle[11] = circle[10] - width - 1;\r\n    circle[12] = circle[11] - width;\r\n    circle[13] = circle[12] - width;\r\n    circle[14] = circle[13] - width + 1;\r\n    circle[15] = circle[14] - width + 1;\r\n\r\n    this.circles_[width] = circle;\r\n    return circle;\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Math utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.Math = {};\r\n\r\n  /**\r\n   * Euclidean distance between two points P(x0, y0) and P(x1, y1).\r\n   * @param {number} x0 Horizontal coordinate of P0.\r\n   * @param {number} y0 Vertical coordinate of P0.\r\n   * @param {number} x1 Horizontal coordinate of P1.\r\n   * @param {number} y1 Vertical coordinate of P1.\r\n   * @return {number} The euclidean distance.\r\n   */\r\n  window.tracking.Math.distance = function(x0, y0, x1, y1) {\r\n    var dx = x1 - x0;\r\n    var dy = y1 - y0;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  };\r\n\r\n  /**\r\n   * Calculates the Hamming weight of a string, which is the number of symbols that are\r\n   * different from the zero-symbol of the alphabet used. It is thus\r\n   * equivalent to the Hamming distance from the all-zero string of the same\r\n   * length. For the most typical case, a string of bits, this is the number\r\n   * of 1's in the string.\r\n   *\r\n   * Example:\r\n   *\r\n   * <pre>\r\n   *  Binary string     Hamming weight\r\n   *   11101                 4\r\n   *   11101010              5\r\n   * </pre>\r\n   *\r\n   * @param {number} i Number that holds the binary string to extract the hamming weight.\r\n   * @return {number} The hamming weight.\r\n   */\r\n  window.tracking.Math.hammingWeight = function(i) {\r\n    i = i - ((i >> 1) & 0x55555555);\r\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\r\n\r\n    return ((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\r\n  };\r\n\r\n  /**\r\n   * Generates a random number between [a, b] interval.\r\n   * @param {number} a\r\n   * @param {number} b\r\n   * @return {number}\r\n   */\r\n  window.tracking.Math.uniformRandom = function(a, b) {\r\n    return a + Math.random() * (b - a);\r\n  };\r\n\r\n  /**\r\n   * Tests if a rectangle intersects with another.\r\n   *\r\n   *  <pre>\r\n   *  x0y0 --------       x2y2 --------\r\n   *      |       |           |       |\r\n   *      -------- x1y1       -------- x3y3\r\n   * </pre>\r\n   *\r\n   * @param {number} x0 Horizontal coordinate of P0.\r\n   * @param {number} y0 Vertical coordinate of P0.\r\n   * @param {number} x1 Horizontal coordinate of P1.\r\n   * @param {number} y1 Vertical coordinate of P1.\r\n   * @param {number} x2 Horizontal coordinate of P2.\r\n   * @param {number} y2 Vertical coordinate of P2.\r\n   * @param {number} x3 Horizontal coordinate of P3.\r\n   * @param {number} y3 Vertical coordinate of P3.\r\n   * @return {boolean}\r\n   */\r\n  window.tracking.Math.intersectRect = function(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Matrix utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.Matrix = {};\r\n\r\n  /**\r\n   * Loops the array organized as major-row order and executes `fn` callback\r\n   * for each iteration. The `fn` callback receives the following parameters:\r\n   * `(r,g,b,a,index,i,j)`, where `r,g,b,a` represents the pixel color with\r\n   * alpha channel, `index` represents the position in the major-row order\r\n   * array and `i,j` the respective indexes positions in two dimensions.\r\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\r\n   *     through.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {function} fn The callback function for each pixel.\r\n   * @param {number} opt_jump Optional jump for the iteration, by default it\r\n   *     is 1, hence loops all the pixels of the array.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.forEach = function(pixels, width, height, fn, opt_jump) {\r\n    opt_jump = opt_jump || 1;\r\n    for (var i = 0; i < height; i += opt_jump) {\r\n      for (var j = 0; j < width; j += opt_jump) {\r\n        var w = i * width * 4 + j * 4;\r\n        fn.call(this, pixels[w], pixels[w + 1], pixels[w + 2], pixels[w + 3], w, i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Calculates the per-element subtraction of two NxM matrices and returns a\r\n   * new NxM matrix as the result.\r\n   * @param {matrix} a The first matrix.\r\n   * @param {matrix} a The second matrix.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.sub = function(a, b){\r\n    var res = window.tracking.Matrix.clone(a);\r\n    for(var i=0; i < res.length; i++){\r\n      for(var j=0; j < res[i].length; j++){\r\n        res[i][j] -= b[i][j];\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Calculates the per-element sum of two NxM matrices and returns a new NxM\r\n   * NxM matrix as the result.\r\n   * @param {matrix} a The first matrix.\r\n   * @param {matrix} a The second matrix.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.add = function(a, b){\r\n    var res = window.tracking.Matrix.clone(a);\r\n    for(var i=0; i < res.length; i++){\r\n      for(var j=0; j < res[i].length; j++){\r\n        res[i][j] += b[i][j];\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Clones a matrix (or part of it) and returns a new matrix as the result.\r\n   * @param {matrix} src The matrix to be cloned.\r\n   * @param {number} width The second matrix.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.clone = function(src, width, height){\r\n    width = width || src[0].length;\r\n    height = height || src.length;\r\n    var temp = new Array(height);\r\n    var i = height;\r\n    while(i--){\r\n      temp[i] = new Array(width);\r\n      var j = width;\r\n      while(j--) temp[i][j] = src[i][j];\r\n    }\r\n    return temp;\r\n  }\r\n\r\n  /**\r\n   * Multiply a matrix by a scalar and returns a new matrix as the result.\r\n   * @param {number} scalar The scalar to multiply the matrix by.\r\n   * @param {matrix} src The matrix to be multiplied.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.mulScalar = function(scalar, src){\r\n    var res = window.tracking.Matrix.clone(src);\r\n    for(var i=0; i < src.length; i++){\r\n      for(var j=0; j < src[i].length; j++){\r\n        res[i][j] *= scalar;\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Transpose a matrix and returns a new matrix as the result.\r\n   * @param {matrix} src The matrix to be transposed.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.transpose = function(src){\r\n    var transpose = new Array(src[0].length);\r\n    for(var i=0; i < src[0].length; i++){\r\n      transpose[i] = new Array(src.length);\r\n      for(var j=0; j < src.length; j++){\r\n        transpose[i][j] = src[j][i];\r\n      }\r\n    }\r\n    return transpose;\r\n  }\r\n\r\n  /**\r\n   * Multiply an MxN matrix with an NxP matrix and returns a new MxP matrix\r\n   * as the result.\r\n   * @param {matrix} a The first matrix.\r\n   * @param {matrix} b The second matrix.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.mul = function(a, b) {\r\n    var res = new Array(a.length);\r\n    for (var i = 0; i < a.length; i++) {\r\n      res[i] = new Array(b[0].length);\r\n      for (var j = 0; j < b[0].length; j++) {\r\n        res[i][j] = 0;\r\n        for (var k = 0; k < a[0].length; k++) {\r\n          res[i][j] += a[i][k] * b[k][j];\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Calculates the absolute norm of a matrix.\r\n   * @param {matrix} src The matrix which norm will be calculated.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.norm = function(src){\r\n    var res = 0;\r\n    for(var i=0; i < src.length; i++){\r\n      for(var j=0; j < src[i].length; j++){\r\n        res += src[i][j]*src[i][j];\r\n      }\r\n    }\r\n    return Math.sqrt(res);\r\n  }\r\n\r\n  /**\r\n   * Calculates and returns the covariance matrix of a set of vectors as well\r\n   * as the mean of the matrix.\r\n   * @param {matrix} src The matrix which covariance matrix will be calculated.\r\n   * @static\r\n   */\r\n  window.tracking.Matrix.calcCovarMatrix = function(src){\r\n\r\n    var mean = new Array(src.length);\r\n    for(var i=0; i < src.length; i++){\r\n      mean[i] = [0.0];\r\n      for(var j=0; j < src[i].length; j++){\r\n        mean[i][0] += src[i][j]/src[i].length;\r\n      }\r\n    }\r\n\r\n    var deltaFull = window.tracking.Matrix.clone(mean);\r\n    for(var i=0; i < deltaFull.length; i++){\r\n      for(var j=0; j < src[0].length - 1; j++){\r\n        deltaFull[i].push(deltaFull[i][0]);\r\n      }\r\n    }\r\n\r\n    var a = window.tracking.Matrix.sub(src, deltaFull);\r\n    var b = window.tracking.Matrix.transpose(a);\r\n    var covar = window.tracking.Matrix.mul(b,a);\r\n    return [covar, mean];\r\n\r\n  }\r\n\r\n}());\r\n(function() {\r\n  /**\r\n   * EPnp utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.EPnP = {};\r\n\r\n  window.tracking.EPnP.solve = function(objectPoints, imagePoints, cameraMatrix) {};\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Tracker utility.\r\n   * @constructor\r\n   * @extends {window.tracking.EventEmitter}\r\n   */\r\n  window.tracking.Tracker = function() {\r\n    window.tracking.Tracker.base(this, 'constructor');\r\n  };\r\n\r\n  window.tracking.inherits(window.tracking.Tracker, window.tracking.EventEmitter);\r\n\r\n  /**\r\n   * Tracks the pixels on the array. This method is called for each video\r\n   * frame in order to emit `track` event.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   */\r\n  window.tracking.Tracker.prototype.track = function() {};\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * TrackerTask utility.\r\n   * @constructor\r\n   * @extends {window.tracking.EventEmitter}\r\n   */\r\n  window.tracking.TrackerTask = function(tracker) {\r\n    window.tracking.TrackerTask.base(this, 'constructor');\r\n\r\n    if (!tracker) {\r\n      throw new Error('Tracker instance not specified.');\r\n    }\r\n\r\n    this.setTracker(tracker);\r\n  };\r\n\r\n  window.tracking.inherits(window.tracking.TrackerTask, window.tracking.EventEmitter);\r\n\r\n  /**\r\n   * Holds the tracker instance managed by this task.\r\n   * @type {window.tracking.Tracker}\r\n   * @private\r\n   */\r\n  window.tracking.TrackerTask.prototype.tracker_ = null;\r\n\r\n  /**\r\n   * Holds if the tracker task is in running.\r\n   * @type {boolean}\r\n   * @private\r\n   */\r\n  window.tracking.TrackerTask.prototype.running_ = false;\r\n\r\n  /**\r\n   * Gets the tracker instance managed by this task.\r\n   * @return {window.tracking.Tracker}\r\n   */\r\n  window.tracking.TrackerTask.prototype.getTracker = function() {\r\n    return this.tracker_;\r\n  };\r\n\r\n  /**\r\n   * Returns true if the tracker task is in running, false otherwise.\r\n   * @return {boolean}\r\n   * @private\r\n   */\r\n  window.tracking.TrackerTask.prototype.inRunning = function() {\r\n    return this.running_;\r\n  };\r\n\r\n  /**\r\n   * Sets if the tracker task is in running.\r\n   * @param {boolean} running\r\n   * @private\r\n   */\r\n  window.tracking.TrackerTask.prototype.setRunning = function(running) {\r\n    this.running_ = running;\r\n  };\r\n\r\n  /**\r\n   * Sets the tracker instance managed by this task.\r\n   * @return {window.tracking.Tracker}\r\n   */\r\n  window.tracking.TrackerTask.prototype.setTracker = function(tracker) {\r\n    this.tracker_ = tracker;\r\n  };\r\n\r\n  /**\r\n   * Emits a `run` event on the tracker task for the implementers to run any\r\n   * child action, e.g. `requestAnimationFrame`.\r\n   * @return {object} Returns itself, so calls can be chained.\r\n   */\r\n  window.tracking.TrackerTask.prototype.run = function() {\r\n    var self = this;\r\n\r\n    if (this.inRunning()) {\r\n      return;\r\n    }\r\n\r\n    this.setRunning(true);\r\n    this.reemitTrackEvent_ = function(event) {\r\n      self.emit('track', event);\r\n    };\r\n    this.tracker_.on('track', this.reemitTrackEvent_);\r\n    this.emit('run');\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Emits a `stop` event on the tracker task for the implementers to stop any\r\n   * child action being done, e.g. `requestAnimationFrame`.\r\n   * @return {object} Returns itself, so calls can be chained.\r\n   */\r\n  window.tracking.TrackerTask.prototype.stop = function() {\r\n    if (!this.inRunning()) {\r\n      return;\r\n    }\r\n\r\n    this.setRunning(false);\r\n    this.emit('stop');\r\n    this.tracker_.removeListener('track', this.reemitTrackEvent_);\r\n    return this;\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * ColorTracker utility to track colored blobs in a frame using color\r\n   * difference evaluation.\r\n   * @constructor\r\n   * @param {string|Array.<string>} opt_colors Optional colors to track.\r\n   * @extends {window.tracking.Tracker}\r\n   */\r\n  window.tracking.ColorTracker = function(opt_colors) {\r\n    window.tracking.ColorTracker.base(this, 'constructor');\r\n\r\n    if (typeof opt_colors === 'string') {\r\n      opt_colors = [opt_colors];\r\n    }\r\n\r\n    if (opt_colors) {\r\n      opt_colors.forEach(function(color) {\r\n        if (!window.tracking.ColorTracker.getColor(color)) {\r\n          throw new Error('Color not valid, try `new window.tracking.ColorTracker(\"magenta\")`.');\r\n        }\r\n      });\r\n      this.setColors(opt_colors);\r\n    }\r\n  };\r\n\r\n  window.tracking.inherits(window.tracking.ColorTracker, window.tracking.Tracker);\r\n\r\n  /**\r\n   * Holds the known colors.\r\n   * @type {Object.<string, function>}\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.ColorTracker.knownColors_ = {};\r\n\r\n  /**\r\n   * Caches coordinates values of the neighbours surrounding a pixel.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\r\n  window.tracking.ColorTracker.neighbours_ = {};\r\n\r\n  /**\r\n   * Registers a color as known color.\r\n   * @param {string} name The color name.\r\n   * @param {function} fn The color function to test if the passed (r,g,b) is\r\n   *     the desired color.\r\n   * @static\r\n   */\r\n  window.tracking.ColorTracker.registerColor = function(name, fn) {\r\n    window.tracking.ColorTracker.knownColors_[name] = fn;\r\n  };\r\n\r\n  /**\r\n   * Gets the known color function that is able to test whether an (r,g,b) is\r\n   * the desired color.\r\n   * @param {string} name The color name.\r\n   * @return {function} The known color test function.\r\n   * @static\r\n   */\r\n  window.tracking.ColorTracker.getColor = function(name) {\r\n    return window.tracking.ColorTracker.knownColors_[name];\r\n  };\r\n\r\n  /**\r\n   * Holds the colors to be tracked by the `ColorTracker` instance.\r\n   * @default ['magenta']\r\n   * @type {Array.<string>}\r\n   */\r\n  window.tracking.ColorTracker.prototype.colors = ['magenta'];\r\n\r\n  /**\r\n   * Holds the minimum dimension to classify a rectangle.\r\n   * @default 20\r\n   * @type {number}\r\n   */\r\n  window.tracking.ColorTracker.prototype.minDimension = 20;\r\n\r\n  /**\r\n   * Holds the maximum dimension to classify a rectangle.\r\n   * @default Infinity\r\n   * @type {number}\r\n   */\r\n  window.tracking.ColorTracker.prototype.maxDimension = Infinity;\r\n\r\n\r\n  /**\r\n   * Holds the minimum group size to be classified as a rectangle.\r\n   * @default 30\r\n   * @type {number}\r\n   */\r\n  window.tracking.ColorTracker.prototype.minGroupSize = 30;\r\n\r\n  /**\r\n   * Calculates the central coordinate from the cloud points. The cloud points\r\n   * are all points that matches the desired color.\r\n   * @param {Array.<number>} cloud Major row order array containing all the\r\n   *     points from the desired color, e.g. [x1, y1, c2, y2, ...].\r\n   * @param {number} total Total numbers of pixels of the desired color.\r\n   * @return {object} Object containing the x, y and estimated z coordinate of\r\n   *     the blog extracted from the cloud points.\r\n   * @private\r\n   */\r\n  window.tracking.ColorTracker.prototype.calculateDimensions_ = function(cloud, total) {\r\n    var maxx = -1;\r\n    var maxy = -1;\r\n    var minx = Infinity;\r\n    var miny = Infinity;\r\n\r\n    for (var c = 0; c < total; c += 2) {\r\n      var x = cloud[c];\r\n      var y = cloud[c + 1];\r\n\r\n      if (x < minx) {\r\n        minx = x;\r\n      }\r\n      if (x > maxx) {\r\n        maxx = x;\r\n      }\r\n      if (y < miny) {\r\n        miny = y;\r\n      }\r\n      if (y > maxy) {\r\n        maxy = y;\r\n      }\r\n    }\r\n\r\n    return {\r\n      width: maxx - minx,\r\n      height: maxy - miny,\r\n      x: minx,\r\n      y: miny\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Gets the colors being tracked by the `ColorTracker` instance.\r\n   * @return {Array.<string>}\r\n   */\r\n  window.tracking.ColorTracker.prototype.getColors = function() {\r\n    return this.colors;\r\n  };\r\n\r\n  /**\r\n   * Gets the minimum dimension to classify a rectangle.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ColorTracker.prototype.getMinDimension = function() {\r\n    return this.minDimension;\r\n  };\r\n\r\n  /**\r\n   * Gets the maximum dimension to classify a rectangle.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ColorTracker.prototype.getMaxDimension = function() {\r\n    return this.maxDimension;\r\n  };\r\n\r\n  /**\r\n   * Gets the minimum group size to be classified as a rectangle.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ColorTracker.prototype.getMinGroupSize = function() {\r\n    return this.minGroupSize;\r\n  };\r\n\r\n  /**\r\n   * Gets the eight offset values of the neighbours surrounding a pixel.\r\n   * @param {number} width The image width.\r\n   * @return {array} Array with the eight offset values of the neighbours\r\n   *     surrounding a pixel.\r\n   * @private\r\n   */\r\n  window.tracking.ColorTracker.prototype.getNeighboursForWidth_ = function(width) {\r\n    if (window.tracking.ColorTracker.neighbours_[width]) {\r\n      return window.tracking.ColorTracker.neighbours_[width];\r\n    }\r\n\r\n    var neighbours = new Int32Array(8);\r\n\r\n    neighbours[0] = -width * 4;\r\n    neighbours[1] = -width * 4 + 4;\r\n    neighbours[2] = 4;\r\n    neighbours[3] = width * 4 + 4;\r\n    neighbours[4] = width * 4;\r\n    neighbours[5] = width * 4 - 4;\r\n    neighbours[6] = -4;\r\n    neighbours[7] = -width * 4 - 4;\r\n\r\n    window.tracking.ColorTracker.neighbours_[width] = neighbours;\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  /**\r\n   * Unites groups whose bounding box intersect with each other.\r\n   * @param {Array.<Object>} rects\r\n   * @private\r\n   */\r\n  window.tracking.ColorTracker.prototype.mergeRectangles_ = function(rects) {\r\n    var intersects;\r\n    var results = [];\r\n    var minDimension = this.getMinDimension();\r\n    var maxDimension = this.getMaxDimension();\r\n\r\n    for (var r = 0; r < rects.length; r++) {\r\n      var r1 = rects[r];\r\n      intersects = true;\r\n      for (var s = r + 1; s < rects.length; s++) {\r\n        var r2 = rects[s];\r\n        if (window.tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\r\n          intersects = false;\r\n          var x1 = Math.min(r1.x, r2.x);\r\n          var y1 = Math.min(r1.y, r2.y);\r\n          var x2 = Math.max(r1.x + r1.width, r2.x + r2.width);\r\n          var y2 = Math.max(r1.y + r1.height, r2.y + r2.height);\r\n          r2.height = y2 - y1;\r\n          r2.width = x2 - x1;\r\n          r2.x = x1;\r\n          r2.y = y1;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (intersects) {\r\n        if (r1.width >= minDimension && r1.height >= minDimension) {\r\n          if (r1.width <= maxDimension && r1.height <= maxDimension) {\r\n            results.push(r1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return results;\r\n  };\r\n\r\n  /**\r\n   * Sets the colors to be tracked by the `ColorTracker` instance.\r\n   * @param {Array.<string>} colors\r\n   */\r\n  window.tracking.ColorTracker.prototype.setColors = function(colors) {\r\n    this.colors = colors;\r\n  };\r\n\r\n  /**\r\n   * Sets the minimum dimension to classify a rectangle.\r\n   * @param {number} minDimension\r\n   */\r\n  window.tracking.ColorTracker.prototype.setMinDimension = function(minDimension) {\r\n    this.minDimension = minDimension;\r\n  };\r\n\r\n  /**\r\n   * Sets the maximum dimension to classify a rectangle.\r\n   * @param {number} maxDimension\r\n   */\r\n  window.tracking.ColorTracker.prototype.setMaxDimension = function(maxDimension) {\r\n    this.maxDimension = maxDimension;\r\n  };\r\n\r\n  /**\r\n   * Sets the minimum group size to be classified as a rectangle.\r\n   * @param {number} minGroupSize\r\n   */\r\n  window.tracking.ColorTracker.prototype.setMinGroupSize = function(minGroupSize) {\r\n    this.minGroupSize = minGroupSize;\r\n  };\r\n\r\n  /**\r\n   * Tracks the `Video` frames. This method is called for each video frame in\r\n   * order to emit `track` event.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   */\r\n  window.tracking.ColorTracker.prototype.track = function(pixels, width, height) {\r\n    var self = this;\r\n    var colors = this.getColors();\r\n\r\n    if (!colors) {\r\n      throw new Error('Colors not specified, try `new window.tracking.ColorTracker(\"magenta\")`.');\r\n    }\r\n\r\n    var results = [];\r\n\r\n    colors.forEach(function(color) {\r\n      results = results.concat(self.trackColor_(pixels, width, height, color));\r\n    });\r\n\r\n    this.emit('track', {\r\n      data: results\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Find the given color in the given matrix of pixels using Flood fill\r\n   * algorithm to determines the area connected to a given node in a\r\n   * multi-dimensional array.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   * @param {string} color The color to be found\r\n   * @private\r\n   */\r\n  window.tracking.ColorTracker.prototype.trackColor_ = function(pixels, width, height, color) {\r\n    var colorFn = window.tracking.ColorTracker.knownColors_[color];\r\n    var currGroup = new Int32Array(pixels.length >> 2);\r\n    var currGroupSize;\r\n    var currI;\r\n    var currJ;\r\n    var currW;\r\n    var marked = new Int8Array(pixels.length);\r\n    var minGroupSize = this.getMinGroupSize();\r\n    var neighboursW = this.getNeighboursForWidth_(width);\r\n    var queue = new Int32Array(pixels.length);\r\n    var queuePosition;\r\n    var results = [];\r\n    var w = -4;\r\n\r\n    if (!colorFn) {\r\n      return results;\r\n    }\r\n\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        w += 4;\r\n\r\n        if (marked[w]) {\r\n          continue;\r\n        }\r\n\r\n        currGroupSize = 0;\r\n\r\n        queuePosition = -1;\r\n        queue[++queuePosition] = w;\r\n        queue[++queuePosition] = i;\r\n        queue[++queuePosition] = j;\r\n\r\n        marked[w] = 1;\r\n\r\n        while (queuePosition >= 0) {\r\n          currJ = queue[queuePosition--];\r\n          currI = queue[queuePosition--];\r\n          currW = queue[queuePosition--];\r\n\r\n          if (colorFn(pixels[currW], pixels[currW + 1], pixels[currW + 2], pixels[currW + 3], currW, currI, currJ)) {\r\n            currGroup[currGroupSize++] = currJ;\r\n            currGroup[currGroupSize++] = currI;\r\n\r\n            for (var k = 0; k < neighboursW.length; k++) {\r\n              var otherW = currW + neighboursW[k];\r\n              var otherI = currI + neighboursI[k];\r\n              var otherJ = currJ + neighboursJ[k];\r\n              if (!marked[otherW] && otherI >= 0 && otherI < height && otherJ >= 0 && otherJ < width) {\r\n                queue[++queuePosition] = otherW;\r\n                queue[++queuePosition] = otherI;\r\n                queue[++queuePosition] = otherJ;\r\n\r\n                marked[otherW] = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (currGroupSize >= minGroupSize) {\r\n          var data = this.calculateDimensions_(currGroup, currGroupSize);\r\n          if (data) {\r\n            data.color = color;\r\n            results.push(data);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.mergeRectangles_(results);\r\n  };\r\n\r\n  // Default colors\r\n  //===================\r\n\r\n  window.tracking.ColorTracker.registerColor('cyan', function(r, g, b) {\r\n    var thresholdGreen = 50,\r\n      thresholdBlue = 70,\r\n      dx = r - 0,\r\n      dy = g - 255,\r\n      dz = b - 255;\r\n\r\n    if ((g - r) >= thresholdGreen && (b - r) >= thresholdBlue) {\r\n      return true;\r\n    }\r\n    return dx * dx + dy * dy + dz * dz < 6400;\r\n  });\r\n\r\n  window.tracking.ColorTracker.registerColor('magenta', function(r, g, b) {\r\n    var threshold = 50,\r\n      dx = r - 255,\r\n      dy = g - 0,\r\n      dz = b - 255;\r\n\r\n    if ((r - g) >= threshold && (b - g) >= threshold) {\r\n      return true;\r\n    }\r\n    return dx * dx + dy * dy + dz * dz < 19600;\r\n  });\r\n\r\n  window.tracking.ColorTracker.registerColor('yellow', function(r, g, b) {\r\n    var threshold = 50,\r\n      dx = r - 255,\r\n      dy = g - 255,\r\n      dz = b - 0;\r\n\r\n    if ((r - b) >= threshold && (g - b) >= threshold) {\r\n      return true;\r\n    }\r\n    return dx * dx + dy * dy + dz * dz < 10000;\r\n  });\r\n\r\n\r\n  // Caching neighbour i/j offset values.\r\n  //=====================================\r\n  var neighboursI = new Int32Array([-1, -1, 0, 1, 1, 1, 0, -1]);\r\n  var neighboursJ = new Int32Array([0, 1, 1, 1, 0, -1, -1, -1]);\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * ObjectTracker utility.\r\n   * @constructor\r\n   * @param {string|Array.<string|Array.<number>>} opt_classifiers Optional\r\n   *     object classifiers to track.\r\n   * @extends {window.tracking.Tracker}\r\n   */\r\n  window.tracking.ObjectTracker = function(opt_classifiers) {\r\n    window.tracking.ObjectTracker.base(this, 'constructor');\r\n\r\n    if (opt_classifiers) {\r\n      if (!Array.isArray(opt_classifiers)) {\r\n        opt_classifiers = [opt_classifiers];\r\n      }\r\n\r\n      if (Array.isArray(opt_classifiers)) {\r\n        opt_classifiers.forEach(function(classifier, i) {\r\n          if (typeof classifier === 'string') {\r\n            opt_classifiers[i] = window.tracking.ViolaJones.classifiers[classifier];\r\n          }\r\n          if (!opt_classifiers[i]) {\r\n            throw new Error('Object classifier not valid, try `new window.tracking.ObjectTracker(\"face\")`.');\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    this.setClassifiers(opt_classifiers);\r\n  };\r\n\r\n  window.tracking.inherits(window.tracking.ObjectTracker, window.tracking.Tracker);\r\n\r\n  /**\r\n   * Specifies the edges density of a block in order to decide whether to skip\r\n   * it or not.\r\n   * @default 0.2\r\n   * @type {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.edgesDensity = 0.2;\r\n\r\n  /**\r\n   * Specifies the initial scale to start the feature block scaling.\r\n   * @default 1.0\r\n   * @type {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.initialScale = 1.0;\r\n\r\n  /**\r\n   * Specifies the scale factor to scale the feature block.\r\n   * @default 1.25\r\n   * @type {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.scaleFactor = 1.25;\r\n\r\n  /**\r\n   * Specifies the block step size.\r\n   * @default 1.5\r\n   * @type {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.stepSize = 1.5;\r\n\r\n  /**\r\n   * Gets the tracker HAAR classifiers.\r\n   * @return {TypedArray.<number>}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.getClassifiers = function() {\r\n    return this.classifiers;\r\n  };\r\n\r\n  /**\r\n   * Gets the edges density value.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.getEdgesDensity = function() {\r\n    return this.edgesDensity;\r\n  };\r\n\r\n  /**\r\n   * Gets the initial scale to start the feature block scaling.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.getInitialScale = function() {\r\n    return this.initialScale;\r\n  };\r\n\r\n  /**\r\n   * Gets the scale factor to scale the feature block.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.getScaleFactor = function() {\r\n    return this.scaleFactor;\r\n  };\r\n\r\n  /**\r\n   * Gets the block step size.\r\n   * @return {number}\r\n   */\r\n  window.tracking.ObjectTracker.prototype.getStepSize = function() {\r\n    return this.stepSize;\r\n  };\r\n\r\n  /**\r\n   * Tracks the `Video` frames. This method is called for each video frame in\r\n   * order to emit `track` event.\r\n   * @param {Uint8ClampedArray} pixels The pixels data to track.\r\n   * @param {number} width The pixels canvas width.\r\n   * @param {number} height The pixels canvas height.\r\n   */\r\n  window.tracking.ObjectTracker.prototype.track = function(pixels, width, height) {\r\n    var self = this;\r\n    var classifiers = this.getClassifiers();\r\n\r\n    if (!classifiers) {\r\n      throw new Error('Object classifier not specified, try `new window.tracking.ObjectTracker(\"face\")`.');\r\n    }\r\n\r\n    var results = [];\r\n\r\n    classifiers.forEach(function(classifier) {\r\n      results = results.concat(window.tracking.ViolaJones.detect(pixels, width, height, self.getInitialScale(), self.getScaleFactor(), self.getStepSize(), self.getEdgesDensity(), classifier));\r\n    });\r\n\r\n    this.emit('track', {\r\n      data: results\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Sets the tracker HAAR classifiers.\r\n   * @param {TypedArray.<number>} classifiers\r\n   */\r\n  window.tracking.ObjectTracker.prototype.setClassifiers = function(classifiers) {\r\n    this.classifiers = classifiers;\r\n  };\r\n\r\n  /**\r\n   * Sets the edges density.\r\n   * @param {number} edgesDensity\r\n   */\r\n  window.tracking.ObjectTracker.prototype.setEdgesDensity = function(edgesDensity) {\r\n    this.edgesDensity = edgesDensity;\r\n  };\r\n\r\n  /**\r\n   * Sets the initial scale to start the block scaling.\r\n   * @param {number} initialScale\r\n   */\r\n  window.tracking.ObjectTracker.prototype.setInitialScale = function(initialScale) {\r\n    this.initialScale = initialScale;\r\n  };\r\n\r\n  /**\r\n   * Sets the scale factor to scale the feature block.\r\n   * @param {number} scaleFactor\r\n   */\r\n  window.tracking.ObjectTracker.prototype.setScaleFactor = function(scaleFactor) {\r\n    this.scaleFactor = scaleFactor;\r\n  };\r\n\r\n  /**\r\n   * Sets the block step size.\r\n   * @param {number} stepSize\r\n   */\r\n  window.tracking.ObjectTracker.prototype.setStepSize = function(stepSize) {\r\n    this.stepSize = stepSize;\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n\r\n\r\n  window.tracking.LandmarksTracker = function() {\r\n    window.tracking.LandmarksTracker.base(this, 'constructor');\r\n  }\r\n\r\n  window.tracking.inherits(window.tracking.LandmarksTracker, window.tracking.ObjectTracker);\r\n\r\n  window.tracking.LandmarksTracker.prototype.track = function(pixels, width, height) {\r\n\r\n    var image = {\r\n      'data': pixels,\r\n      'width': width,\r\n      'height': height\r\n    };\r\n\r\n    var classifier = window.tracking.ViolaJones.classifiers['face'];\r\n\r\n    var faces = window.tracking.ViolaJones.detect(pixels, width, height,\r\n      this.getInitialScale(), this.getScaleFactor(), this.getStepSize(),\r\n      this.getEdgesDensity(), classifier);\r\n\r\n    var landmarks = window.tracking.LBF.align(pixels, width, height, faces);\r\n\r\n    this.emit('track', {\r\n      'data': {\r\n        'faces' : faces,\r\n        'landmarks' : landmarks\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n}());\r\n\r\n(function() {\r\n\r\n  window.tracking.LBF = {};\r\n\r\n  /**\r\n   * LBF Regressor utility.\r\n   * @constructor\r\n   */\r\n  window.tracking.LBF.Regressor = function(maxNumStages){\r\n    this.maxNumStages = maxNumStages;\r\n\r\n    this.rfs = new Array(maxNumStages);\r\n    this.models = new Array(maxNumStages);\r\n    for(var i=0; i < maxNumStages; i++){\r\n      this.rfs[i] = new window.tracking.LBF.RandomForest(i);\r\n      this.models[i] = window.tracking.LBF.RegressorData[i].models;\r\n    }\r\n\r\n    this.meanShape = window.tracking.LBF.LandmarksData;\r\n  }\r\n\r\n  /**\r\n   * Predicts the position of the landmarks based on the bounding box of the face.\r\n   * @param {pixels} pixels The grayscale pixels in a linear array.\r\n   * @param {number} width Width of the image.\r\n   * @param {number} height Height of the image.\r\n   * @param {object} boudingBox Bounding box of the face to be aligned.\r\n   * @return {matrix} A matrix with each landmark position in a row [x,y].\r\n   */\r\n  window.tracking.LBF.Regressor.prototype.predict = function(pixels, width, height, boundingBox) {\r\n\r\n    var images = [];\r\n    var currentShapes = [];\r\n    var boundingBoxes = [];\r\n\r\n    var meanShapeClone = window.tracking.Matrix.clone(this.meanShape);\r\n\r\n    images.push({\r\n      'data': pixels,\r\n      'width': width,\r\n      'height': height\r\n    });\r\n    boundingBoxes.push(boundingBox);\r\n\r\n    currentShapes.push(window.tracking.LBF.projectShapeToBoundingBox_(meanShapeClone, boundingBox));\r\n\r\n    for(var stage = 0; stage < this.maxNumStages; stage++){\r\n      var binaryFeatures = window.tracking.LBF.Regressor.deriveBinaryFeat(this.rfs[stage], images, currentShapes, boundingBoxes, meanShapeClone);\r\n      this.applyGlobalPrediction(binaryFeatures, this.models[stage], currentShapes, boundingBoxes);\r\n    }\r\n\r\n    return currentShapes[0];\r\n  };\r\n\r\n  /**\r\n   * Multiplies the binary features of the landmarks with the regression matrix\r\n   * to obtain the displacement for each landmark. Then applies this displacement\r\n   * into the landmarks shape.\r\n   * @param {object} binaryFeatures The binary features for the landmarks.\r\n   * @param {object} models The regressor models.\r\n   * @param {matrix} currentShapes The landmarks shapes.\r\n   * @param {array} boudingBoxes The bounding boxes of the faces.\r\n   */\r\n  window.tracking.LBF.Regressor.prototype.applyGlobalPrediction = function(binaryFeatures, models, currentShapes,\r\n    boundingBoxes){\r\n\r\n    var residual = currentShapes[0].length * 2;\r\n\r\n    var rotation = [];\r\n    var deltashape = new Array(residual/2);\r\n    for(var i=0; i < residual/2; i++){\r\n      deltashape[i] = [0.0, 0.0];\r\n    }\r\n\r\n    for(var i=0; i < currentShapes.length; i++){\r\n      for(var j=0; j < residual; j++){\r\n        var tmp = 0;\r\n        for(var lx=0, idx=0; (idx = binaryFeatures[i][lx].index) != -1; lx++){\r\n          if(idx <= models[j].nr_feature){\r\n            tmp += models[j].data[(idx - 1)] * binaryFeatures[i][lx].value;\r\n          }\r\n        }\r\n        if(j < residual/2){\r\n          deltashape[j][0] = tmp;\r\n        }else{\r\n          deltashape[j - residual/2][1] = tmp;\r\n        }\r\n      }\r\n\r\n      var res = window.tracking.LBF.similarityTransform_(window.tracking.LBF.unprojectShapeToBoundingBox_(currentShapes[i], boundingBoxes[i]), this.meanShape);\r\n      var rotation = window.tracking.Matrix.transpose(res[0]);\r\n\r\n      var s = window.tracking.LBF.unprojectShapeToBoundingBox_(currentShapes[i], boundingBoxes[i]);\r\n      s = window.tracking.Matrix.add(s, deltashape);\r\n\r\n      currentShapes[i] = window.tracking.LBF.projectShapeToBoundingBox_(s, boundingBoxes[i]);\r\n\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Derives the binary features from the image for each landmark.\r\n   * @param {object} forest The random forest to search for the best binary feature match.\r\n   * @param {array} images The images with pixels in a grayscale linear array.\r\n   * @param {array} currentShapes The current landmarks shape.\r\n   * @param {array} boudingBoxes The bounding boxes of the faces.\r\n   * @param {matrix} meanShape The mean shape of the current landmarks set.\r\n   * @return {array} The binary features extracted from the image and matched with the\r\n   *     training data.\r\n   * @static\r\n   */\r\n  window.tracking.LBF.Regressor.deriveBinaryFeat = function(forest, images, currentShapes, boundingBoxes, meanShape){\r\n\r\n    var binaryFeatures = new Array(images.length);\r\n    for(var i=0; i < images.length; i++){\r\n      var t = forest.maxNumTrees * forest.landmarkNum + 1;\r\n      binaryFeatures[i] = new Array(t);\r\n      for(var j=0; j < t; j++){\r\n        binaryFeatures[i][j] = {};\r\n      }\r\n    }\r\n\r\n    var leafnodesPerTree = 1 << (forest.maxDepth - 1);\r\n\r\n    for(var i=0; i < images.length; i++){\r\n\r\n      var projectedShape = window.tracking.LBF.unprojectShapeToBoundingBox_(currentShapes[i], boundingBoxes[i]);\r\n      var transform = window.tracking.LBF.similarityTransform_(projectedShape, meanShape);\r\n\r\n      for(var j=0; j < forest.landmarkNum; j++){\r\n        for(var k=0; k < forest.maxNumTrees; k++){\r\n\r\n          var binaryCode = window.tracking.LBF.Regressor.getCodeFromTree(forest.rfs[j][k], images[i],\r\n                              currentShapes[i], boundingBoxes[i], transform[0], transform[1]);\r\n\r\n          var index = j*forest.maxNumTrees + k;\r\n          binaryFeatures[i][index].index = leafnodesPerTree * index + binaryCode;\r\n          binaryFeatures[i][index].value = 1;\r\n\r\n        }\r\n      }\r\n      binaryFeatures[i][forest.landmarkNum * forest.maxNumTrees].index = -1;\r\n      binaryFeatures[i][forest.landmarkNum * forest.maxNumTrees].value = -1;\r\n    }\r\n    return binaryFeatures;\r\n\r\n  }\r\n\r\n  /**\r\n   * Gets the binary code for a specific tree in a random forest. For each landmark,\r\n   * the position from two pre-defined points are recovered from the training data\r\n   * and then the intensity of the pixels corresponding to these points is extracted\r\n   * from the image and used to traverse the trees in the random forest. At the end,\r\n   * the ending nodes will be represented by 1, and the remaining nodes by 0.\r\n   *\r\n   * +--------------------------- Random Forest -----------------------------+\r\n   * | Ø = Ending leaf                                                       |\r\n   * |                                                                       |\r\n   * |       O             O             O             O             O       |\r\n   * |     /   \\         /   \\         /   \\         /   \\         /   \\     |\r\n   * |    O     O       O     O       O     O       O     O       O     O    |\r\n   * |   / \\   / \\     / \\   / \\     / \\   / \\     / \\   / \\     / \\   / \\   |\r\n   * |  Ø   O O   O   O   O Ø   O   O   Ø O   O   O   O Ø   O   O   O O   Ø  |\r\n   * |  1   0 0   0   0   0 1   0   0   1 0   0   0   0 1   0   0   0 0   1  |\r\n   * +-----------------------------------------------------------------------+\r\n   * Final binary code for this landmark: 10000010010000100001\r\n   *\r\n   * @param {object} forest The tree to be analyzed.\r\n   * @param {array} image The image with pixels in a grayscale linear array.\r\n   * @param {matrix} shape The current landmarks shape.\r\n   * @param {object} boudingBoxes The bounding box of the face.\r\n   * @param {matrix} rotation The rotation matrix used to transform the projected landmarks\r\n   *     into the mean shape.\r\n   * @param {number} scale The scale factor used to transform the projected landmarks\r\n   *     into the mean shape.\r\n   * @return {number} The binary code extracted from the tree.\r\n   * @static\r\n   */\r\n  window.tracking.LBF.Regressor.getCodeFromTree = function(tree, image, shape, boundingBox, rotation, scale){\r\n    var current = 0;\r\n    var bincode = 0;\r\n\r\n    while(true){\r\n\r\n      var x1 = Math.cos(tree.nodes[current].feats[0]) * tree.nodes[current].feats[2] * tree.maxRadioRadius * boundingBox.width;\r\n      var y1 = Math.sin(tree.nodes[current].feats[0]) * tree.nodes[current].feats[2] * tree.maxRadioRadius * boundingBox.height;\r\n      var x2 = Math.cos(tree.nodes[current].feats[1]) * tree.nodes[current].feats[3] * tree.maxRadioRadius * boundingBox.width;\r\n      var y2 = Math.sin(tree.nodes[current].feats[1]) * tree.nodes[current].feats[3] * tree.maxRadioRadius * boundingBox.height;\r\n\r\n      var project_x1 = rotation[0][0] * x1 + rotation[0][1] * y1;\r\n      var project_y1 = rotation[1][0] * x1 + rotation[1][1] * y1;\r\n\r\n      var real_x1 = Math.floor(project_x1 + shape[tree.landmarkID][0]);\r\n      var real_y1 = Math.floor(project_y1 + shape[tree.landmarkID][1]);\r\n      real_x1 = Math.max(0.0, Math.min(real_x1, image.height - 1.0));\r\n      real_y1 = Math.max(0.0, Math.min(real_y1, image.width - 1.0));\r\n\r\n      var project_x2 = rotation[0][0] * x2 + rotation[0][1] * y2;\r\n      var project_y2 = rotation[1][0] * x2 + rotation[1][1] * y2;\r\n\r\n      var real_x2 = Math.floor(project_x2 + shape[tree.landmarkID][0]);\r\n      var real_y2 = Math.floor(project_y2 + shape[tree.landmarkID][1]);\r\n      real_x2 = Math.max(0.0, Math.min(real_x2, image.height - 1.0));\r\n      real_y2 = Math.max(0.0, Math.min(real_y2, image.width - 1.0));\r\n      var pdf = Math.floor(image.data[real_y1*image.width + real_x1]) -\r\n          Math.floor(image.data[real_y2 * image.width +real_x2]);\r\n\r\n      if(pdf < tree.nodes[current].thresh){\r\n        current = tree.nodes[current].cnodes[0];\r\n      }else{\r\n        current = tree.nodes[current].cnodes[1];\r\n      }\r\n\r\n      if (tree.nodes[current].is_leafnode == 1) {\r\n        bincode = 1;\r\n        for (var i=0; i < tree.leafnodes.length; i++) {\r\n          if (tree.leafnodes[i] == current) {\r\n            return bincode;\r\n          }\r\n          bincode++;\r\n        }\r\n        return bincode;\r\n      }\r\n\r\n    }\r\n\r\n    return bincode;\r\n  }\r\n\r\n}());\r\n(function() {\r\n  /**\r\n   * Face Alignment via Regressing Local Binary Features (LBF)\r\n   * This approach has two components: a set of local binary features and\r\n   * a locality principle for learning those features.\r\n   * The locality principle is used to guide the learning of a set of highly\r\n   * discriminative local binary features for each landmark independently.\r\n   * The obtained local binary features are used to learn a linear regression\r\n   * that later will be used to guide the landmarks in the alignment phase.\r\n   *\r\n   * @authors: VoxarLabs Team (http://cin.ufpe.br/~voxarlabs)\r\n   *           Lucas Figueiredo <lsf@cin.ufpe.br>, Thiago Menezes <tmc2@cin.ufpe.br>,\r\n   *           Thiago Domingues <tald@cin.ufpe.br>, Rafael Roberto <rar3@cin.ufpe.br>,\r\n   *           Thulio Araujo <tlsa@cin.ufpe.br>, Joao Victor <jvfl@cin.ufpe.br>,\r\n   *           Tomer Simis <tls@cin.ufpe.br>)\r\n   */\r\n\r\n  /**\r\n   * Holds the maximum number of stages that will be used in the alignment algorithm.\r\n   * Each stage contains a different set of random forests and retrieves the binary\r\n   * code from a more \"specialized\" (i.e. smaller) region around the landmarks.\r\n   * @type {number}\r\n   * @static\r\n   */\r\n  window.tracking.LBF.maxNumStages = 4;\r\n\r\n  /**\r\n   * Holds the regressor that will be responsible for extracting the local features from\r\n   * the image and guide the landmarks using the training data.\r\n   * @type {object}\r\n   * @protected\r\n   * @static\r\n   */\r\n  window.tracking.LBF.regressor_ = null;\r\n\r\n  /**\r\n   * Generates a set of landmarks for a set of faces\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} faces The list of faces detected in the image\r\n   * @return {array} The aligned landmarks, each set of landmarks corresponding\r\n   *     to a specific face.\r\n   * @static\r\n   */\r\n  window.tracking.LBF.align = function(pixels, width, height, faces){\r\n\r\n    if(window.tracking.LBF.regressor_ == null){\r\n      window.tracking.LBF.regressor_ = new window.tracking.LBF.Regressor(\r\n        window.tracking.LBF.maxNumStages\r\n      );\r\n    }\r\n\r\n    pixels = window.tracking.Image.grayscale(pixels, width, height, false);\r\n\r\n    pixels = window.tracking.Image.equalizeHist(pixels, width, height);\r\n\r\n    var shapes = new Array(faces.length);\r\n\r\n    for(var i in faces){\r\n\r\n      faces[i].height = faces[i].width;\r\n\r\n      var boundingBox = {};\r\n      boundingBox.startX = faces[i].x;\r\n      boundingBox.startY = faces[i].y;\r\n      boundingBox.width = faces[i].width;\r\n      boundingBox.height = faces[i].height;\r\n\r\n      shapes[i] = window.tracking.LBF.regressor_.predict(pixels, width, height, boundingBox);\r\n    }\r\n\r\n    return shapes;\r\n  }\r\n\r\n  /**\r\n   * Unprojects the landmarks shape from the bounding box.\r\n   * @param {matrix} shape The landmarks shape.\r\n   * @param {matrix} boudingBox The bounding box.\r\n   * @return {matrix} The landmarks shape projected into the bounding box.\r\n   * @static\r\n   * @protected\r\n   */\r\n  window.tracking.LBF.unprojectShapeToBoundingBox_ = function(shape, boundingBox){\r\n    var temp = new Array(shape.length);\r\n    for(var i=0; i < shape.length; i++){\r\n      temp[i] = [\r\n        (shape[i][0] - boundingBox.startX) / boundingBox.width,\r\n        (shape[i][1] - boundingBox.startY) / boundingBox.height\r\n      ];\r\n    }\r\n    return temp;\r\n  }\r\n\r\n  /**\r\n   * Projects the landmarks shape into the bounding box. The landmarks shape has\r\n   * normalized coordinates, so it is necessary to map these coordinates into\r\n   * the bounding box coordinates.\r\n   * @param {matrix} shape The landmarks shape.\r\n   * @param {matrix} boudingBox The bounding box.\r\n   * @return {matrix} The landmarks shape.\r\n   * @static\r\n   * @protected\r\n   */\r\n  window.tracking.LBF.projectShapeToBoundingBox_ = function(shape, boundingBox){\r\n    var temp = new Array(shape.length);\r\n    for(var i=0; i < shape.length; i++){\r\n      temp[i] = [\r\n        shape[i][0] * boundingBox.width + boundingBox.startX,\r\n        shape[i][1] * boundingBox.height + boundingBox.startY\r\n      ];\r\n    }\r\n    return temp;\r\n  }\r\n\r\n  /**\r\n   * Calculates the rotation and scale necessary to transform shape1 into shape2.\r\n   * @param {matrix} shape1 The shape to be transformed.\r\n   * @param {matrix} shape2 The shape to be transformed in.\r\n   * @return {[matrix, scalar]} The rotation matrix and scale that applied to shape1\r\n   *     results in shape2.\r\n   * @static\r\n   * @protected\r\n   */\r\n  window.tracking.LBF.similarityTransform_ = function(shape1, shape2){\r\n\r\n    var center1 = [0,0];\r\n    var center2 = [0,0];\r\n    for (var i = 0; i < shape1.length; i++) {\r\n      center1[0] += shape1[i][0];\r\n      center1[1] += shape1[i][1];\r\n      center2[0] += shape2[i][0];\r\n      center2[1] += shape2[i][1];\r\n    }\r\n    center1[0] /= shape1.length;\r\n    center1[1] /= shape1.length;\r\n    center2[0] /= shape2.length;\r\n    center2[1] /= shape2.length;\r\n\r\n    var temp1 = window.tracking.Matrix.clone(shape1);\r\n    var temp2 = window.tracking.Matrix.clone(shape2);\r\n    for(var i=0; i < shape1.length; i++){\r\n      temp1[i][0] -= center1[0];\r\n      temp1[i][1] -= center1[1];\r\n      temp2[i][0] -= center2[0];\r\n      temp2[i][1] -= center2[1];\r\n    }\r\n\r\n    var covariance1, covariance2;\r\n    var mean1, mean2;\r\n\r\n    var t = window.tracking.Matrix.calcCovarMatrix(temp1);\r\n    covariance1 = t[0];\r\n    mean1 = t[1];\r\n\r\n    t = window.tracking.Matrix.calcCovarMatrix(temp2);\r\n    covariance2 = t[0];\r\n    mean2 = t[1];\r\n\r\n    var s1 = Math.sqrt(window.tracking.Matrix.norm(covariance1));\r\n    var s2 = Math.sqrt(window.tracking.Matrix.norm(covariance2));\r\n\r\n    var scale = s1/s2;\r\n    temp1 = window.tracking.Matrix.mulScalar(1.0/s1, temp1);\r\n    temp2 = window.tracking.Matrix.mulScalar(1.0/s2, temp2);\r\n\r\n    var num = 0, den = 0;\r\n    for (var i = 0; i < shape1.length; i++) {\r\n      num = num + temp1[i][1] * temp2[i][0] - temp1[i][0] * temp2[i][1];\r\n      den = den + temp1[i][0] * temp2[i][0] + temp1[i][1] * temp2[i][1];\r\n    }\r\n\r\n    var norm = Math.sqrt(num*num + den*den);\r\n    var sin_theta = num/norm;\r\n    var cos_theta = den/norm;\r\n    var rotation = [\r\n      [cos_theta, -sin_theta],\r\n      [sin_theta, cos_theta]\r\n    ];\r\n\r\n    return [rotation, scale];\r\n  }\r\n\r\n  /**\r\n   * LBF Random Forest data structure.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.LBF.RandomForest = function(forestIndex){\r\n    this.maxNumTrees = window.tracking.LBF.RegressorData[forestIndex].max_numtrees;\r\n    this.landmarkNum = window.tracking.LBF.RegressorData[forestIndex].num_landmark;\r\n    this.maxDepth = window.tracking.LBF.RegressorData[forestIndex].max_depth;\r\n    this.stages = window.tracking.LBF.RegressorData[forestIndex].stages;\r\n\r\n    this.rfs = new Array(this.landmarkNum);\r\n    for(var i=0; i < this.landmarkNum; i++){\r\n      this.rfs[i] = new Array(this.maxNumTrees);\r\n      for(var j=0; j < this.maxNumTrees; j++){\r\n        this.rfs[i][j] = new window.tracking.LBF.Tree(forestIndex, i, j);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * LBF Tree data structure.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  window.tracking.LBF.Tree = function(forestIndex, landmarkIndex, treeIndex){\r\n    var data = window.tracking.LBF.RegressorData[forestIndex].landmarks[landmarkIndex][treeIndex];\r\n    this.maxDepth = data.max_depth;\r\n    this.maxNumNodes = data.max_numnodes;\r\n    this.nodes = data.nodes;\r\n    this.landmarkID = data.landmark_id;\r\n    this.numLeafnodes = data.num_leafnodes;\r\n    this.numNodes = data.num_nodes;\r\n    this.maxNumFeats = data.max_numfeats;\r\n    this.maxRadioRadius = data.max_radio_radius;\r\n    this.leafnodes = data.id_leafnodes;\r\n  }\r\n\r\n}());\r\n\r\nexport default faceDetect;\r\n"]},"metadata":{},"sourceType":"module"}